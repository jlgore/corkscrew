package main

import (
	"context"
	"fmt"
	"log"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v6"
	pb "github.com/jlgore/corkscrew/internal/proto"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// ExampleComputeScanner demonstrates a generated scanner for Azure Compute resources
// This would normally be generated by the scanner generator
type ExampleComputeScanner struct {
	version     string
	serviceName string
}

// NewComputeScanner creates a new compute scanner instance
// This function would be exported for the plugin system
func NewComputeScanner() Scanner {
	return &ExampleComputeScanner{
		version:     "1.0.0",
		serviceName: "compute",
	}
}

// ScanResources implements the Scanner interface for compute resources
func (s *ExampleComputeScanner) ScanResources(ctx context.Context, credential interface{}, subscriptionID string, filters map[string]string) ([]*pb.Resource, error) {
	log.Printf("Scanning Azure Compute resources for subscription: %s", subscriptionID)

	// Cast credential to the expected type
	azCredential, ok := credential.(azcore.TokenCredential)
	if !ok {
		return nil, fmt.Errorf("invalid credential type for Azure")
	}

	// Create compute client
	client, err := armcompute.NewVirtualMachinesClient(subscriptionID, azCredential, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create compute client: %w", err)
	}

	var resources []*pb.Resource

	// List all virtual machines
	vmPager := client.NewListAllPager(nil)
	for vmPager.More() {
		page, err := vmPager.NextPage(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to list virtual machines: %w", err)
		}

		for _, vm := range page.Value {
			resource := s.convertVMToResource(vm, subscriptionID)
			
			// Apply filters
			if s.matchesFilters(resource, filters) {
				resources = append(resources, resource)
			}
		}
	}

	// List disks
	diskClient, err := armcompute.NewDisksClient(subscriptionID, azCredential, nil)
	if err != nil {
		log.Printf("Warning: Failed to create disk client: %v", err)
	} else {
		diskPager := diskClient.NewListPager(nil)
		for diskPager.More() {
			page, err := diskPager.NextPage(ctx)
			if err != nil {
				log.Printf("Warning: Failed to list disks: %v", err)
				break
			}

			for _, disk := range page.Value {
				resource := s.convertDiskToResource(disk, subscriptionID)
				
				// Apply filters
				if s.matchesFilters(resource, filters) {
					resources = append(resources, resource)
				}
			}
		}
	}

	log.Printf("Found %d compute resources", len(resources))
	return resources, nil
}

// GetSupportedServices returns the list of services this scanner supports
func (s *ExampleComputeScanner) GetSupportedServices() []string {
	return []string{"compute", "virtualMachines", "disks", "availabilitySets"}
}

// GetServiceName returns the primary service name
func (s *ExampleComputeScanner) GetServiceName() string {
	return s.serviceName
}

// GetVersion returns the scanner version
func (s *ExampleComputeScanner) GetVersion() string {
	return s.version
}

// convertVMToResource converts an Azure VM to a protobuf Resource
func (s *ExampleComputeScanner) convertVMToResource(vm *armcompute.VirtualMachine, subscriptionID string) *pb.Resource {
	resource := &pb.Resource{
		Provider:     "azure",
		Service:      "compute",
		Type:         "Microsoft.Compute/virtualMachines",
		DiscoveredAt: timestamppb.Now(),
		Tags:         make(map[string]string),
	}

	if vm.ID != nil {
		resource.Id = *vm.ID
	}
	if vm.Name != nil {
		resource.Name = *vm.Name
	}
	if vm.Location != nil {
		resource.Region = *vm.Location
	}

	resource.AccountId = subscriptionID

	// Extract resource group from ID
	if resourceGroup := extractResourceGroupFromID(resource.Id); resourceGroup != "" {
		resource.ParentId = resourceGroup
	}

	// Extract tags
	if vm.Tags != nil {
		for k, v := range vm.Tags {
			if v != nil {
				resource.Tags[k] = *v
			}
		}
	}

	// Add compute-specific attributes
	if vm.Properties != nil {
		if vm.Properties.VMID != nil {
			resource.Tags["vm_id"] = *vm.Properties.VMID
		}
		if vm.Properties.HardwareProfile != nil && vm.Properties.HardwareProfile.VMSize != nil {
			resource.Tags["vm_size"] = string(*vm.Properties.HardwareProfile.VMSize)
		}
		if vm.Properties.ProvisioningState != nil {
			resource.Tags["provisioning_state"] = *vm.Properties.ProvisioningState
		}
	}

	return resource
}

// convertDiskToResource converts an Azure disk to a protobuf Resource
func (s *ExampleComputeScanner) convertDiskToResource(disk *armcompute.Disk, subscriptionID string) *pb.Resource {
	resource := &pb.Resource{
		Provider:     "azure",
		Service:      "compute",
		Type:         "Microsoft.Compute/disks",
		DiscoveredAt: timestamppb.Now(),
		Tags:         make(map[string]string),
	}

	if disk.ID != nil {
		resource.Id = *disk.ID
	}
	if disk.Name != nil {
		resource.Name = *disk.Name
	}
	if disk.Location != nil {
		resource.Region = *disk.Location
	}

	resource.AccountId = subscriptionID

	// Extract resource group from ID
	if resourceGroup := extractResourceGroupFromID(resource.Id); resourceGroup != "" {
		resource.ParentId = resourceGroup
	}

	// Extract tags
	if disk.Tags != nil {
		for k, v := range disk.Tags {
			if v != nil {
				resource.Tags[k] = *v
			}
		}
	}

	// Add disk-specific attributes
	if disk.Properties != nil {
		if disk.Properties.DiskSizeGB != nil {
			resource.Tags["disk_size_gb"] = fmt.Sprintf("%d", *disk.Properties.DiskSizeGB)
		}
		if disk.Properties.DiskState != nil {
			resource.Tags["disk_state"] = string(*disk.Properties.DiskState)
		}
		if disk.Properties.CreationData != nil && disk.Properties.CreationData.CreateOption != nil {
			resource.Tags["create_option"] = string(*disk.Properties.CreationData.CreateOption)
		}
	}

	return resource
}

// matchesFilters checks if a resource matches the provided filters
func (s *ExampleComputeScanner) matchesFilters(resource *pb.Resource, filters map[string]string) bool {
	if filters == nil {
		return true
	}

	// Check resource group filter
	if rgFilter, ok := filters["resource_group"]; ok {
		if resource.ParentId != rgFilter {
			return false
		}
	}

	// Check location filter
	if locationFilter, ok := filters["location"]; ok {
		if resource.Region != locationFilter {
			return false
		}
	}

	// Check tag filters
	for key, value := range filters {
		if key == "resource_group" || key == "location" {
			continue // Already handled above
		}
		
		// Check if it's a tag filter (format: tag:key=value)
		if len(key) > 4 && key[:4] == "tag:" {
			tagKey := key[4:]
			if tagValue, exists := resource.Tags[tagKey]; !exists || tagValue != value {
				return false
			}
		}
	}

	return true
}

// Helper function to extract resource group from Azure resource ID
// Note: This uses the existing function from database_integration.go to avoid duplication

// ExampleStorageScanner demonstrates another generated scanner for Storage resources
type ExampleStorageScanner struct {
	version     string
	serviceName string
}

// NewStorageScanner creates a new storage scanner instance
func NewStorageScanner() Scanner {
	return &ExampleStorageScanner{
		version:     "1.0.0",
		serviceName: "storage",
	}
}

// ScanResources implements the Scanner interface for storage resources
func (s *ExampleStorageScanner) ScanResources(ctx context.Context, credential interface{}, subscriptionID string, filters map[string]string) ([]*pb.Resource, error) {
	log.Printf("Scanning Azure Storage resources for subscription: %s", subscriptionID)

	// This would implement storage account scanning similar to the compute example
	// For brevity, returning empty slice
	return []*pb.Resource{}, nil
}

// GetSupportedServices returns the list of services this scanner supports
func (s *ExampleStorageScanner) GetSupportedServices() []string {
	return []string{"storage", "storageAccounts", "blobServices", "fileServices"}
}

// GetServiceName returns the primary service name
func (s *ExampleStorageScanner) GetServiceName() string {
	return s.serviceName
}

// GetVersion returns the scanner version
func (s *ExampleStorageScanner) GetVersion() string {
	return s.version
}