
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>azure-provider: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jlgore/corkscrew/plugins/azure-provider/azure_provider.go (0.0%)</option>
				
				<option value="file1">github.com/jlgore/corkscrew/plugins/azure-provider/client_factory.go (0.0%)</option>
				
				<option value="file2">github.com/jlgore/corkscrew/plugins/azure-provider/database_integration.go (0.0%)</option>
				
				<option value="file3">github.com/jlgore/corkscrew/plugins/azure-provider/db_schema.go (0.0%)</option>
				
				<option value="file4">github.com/jlgore/corkscrew/plugins/azure-provider/discovery.go (0.0%)</option>
				
				<option value="file5">github.com/jlgore/corkscrew/plugins/azure-provider/main.go (0.0%)</option>
				
				<option value="file6">github.com/jlgore/corkscrew/plugins/azure-provider/resource_graph.go (0.0%)</option>
				
				<option value="file7">github.com/jlgore/corkscrew/plugins/azure-provider/scanner.go (0.0%)</option>
				
				<option value="file8">github.com/jlgore/corkscrew/plugins/azure-provider/schema_generator.go (92.4%)</option>
				
				<option value="file9">github.com/jlgore/corkscrew/plugins/azure-provider/test_helpers.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/exec"
        "strings"
        "sync"
        "time"

        "github.com/Azure/azure-sdk-for-go/sdk/azcore"
        "github.com/Azure/azure-sdk-for-go/sdk/azidentity"
        pb "github.com/jlgore/corkscrew/internal/proto"
        "golang.org/x/time/rate"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// ResourceCache provides caching for discovered services
type ResourceCache struct {
        mu       sync.RWMutex
        services []*pb.ServiceInfo
        ttl      time.Duration
        lastSet  time.Time
}

func NewResourceCache(ttl time.Duration) *ResourceCache <span class="cov0" title="0">{
        return &amp;ResourceCache{
                ttl: ttl,
        }
}</span>

func (c *ResourceCache) GetServices() []*pb.ServiceInfo <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        if time.Since(c.lastSet) &gt; c.ttl </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.services</span>
}

func (c *ResourceCache) SetServices(services []*pb.ServiceInfo) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.services = services
        c.lastSet = time.Now()
}</span>

// ErrorHandler provides error handling utilities
type ErrorHandler struct {
        mu sync.RWMutex
}

func NewErrorHandler() *ErrorHandler <span class="cov0" title="0">{
        return &amp;ErrorHandler{}
}</span>

// AzureProvider implements the CloudProvider interface for Azure
type AzureProvider struct {
        mu             sync.RWMutex
        initialized    bool
        credential     azcore.TokenCredential
        subscriptionID string
        tenantID       string

        // Core components
        discovery     *AzureServiceDiscovery
        scanner       *AzureResourceScanner
        schemaGen     *AzureSchemaGenerator
        clientFactory *AzureClientFactory
        resourceGraph *ResourceGraphClient

        // Database integration
        database *AzureDatabaseIntegration

        // Performance components
        cache        *ResourceCache
        rateLimiter  *rate.Limiter
        errorHandler *ErrorHandler

        // Configuration
        maxConcurrency  int
        enableStreaming bool
        cacheDir        string
}

// NewAzureProvider creates a new Azure provider instance
func NewAzureProvider() *AzureProvider <span class="cov0" title="0">{
        return &amp;AzureProvider{
                cache:           NewResourceCache(24 * time.Hour),
                rateLimiter:     rate.NewLimiter(rate.Limit(100), 200), // 100 requests/sec, burst 200
                maxConcurrency:  10,
                enableStreaming: true,
                errorHandler:    NewErrorHandler(),
        }
}</span>

// getAzureCliSubscription attempts to get the current Azure CLI subscription
func getAzureCliSubscription() string <span class="cov0" title="0">{
        // First check environment variable
        if sub := os.Getenv("AZURE_SUBSCRIPTION_ID"); sub != "" </span><span class="cov0" title="0">{
                return sub
        }</span>
        
        // Try to get from Azure CLI
        <span class="cov0" title="0">cmd := exec.Command("az", "account", "show", "--query", "id", "-o", "tsv")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">return strings.TrimSpace(string(output))</span>
}

// Initialize sets up the Azure provider with credentials and configuration
func (p *AzureProvider) Initialize(ctx context.Context, req *pb.InitializeRequest) (*pb.InitializeResponse, error) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()

        // Extract Azure-specific configuration
        subscriptionID := req.Config["subscription_id"]
        
        // If subscription_id not provided, try to get it from Azure CLI context
        if subscriptionID == "" </span><span class="cov0" title="0">{
                // Try to get subscription from Azure CLI
                if cliSub := getAzureCliSubscription(); cliSub != "" </span><span class="cov0" title="0">{
                        subscriptionID = cliSub
                        log.Printf("Using subscription from Azure CLI: %s", subscriptionID)
                }</span>
        }
        
        <span class="cov0" title="0">log.Printf("Initializing Azure provider with subscription: %s", subscriptionID)
        
        if subscriptionID == "" </span><span class="cov0" title="0">{
                return &amp;pb.InitializeResponse{
                        Success: false,
                        Error:   "subscription_id is required - set AZURE_SUBSCRIPTION_ID or use 'az login'",
                }, nil
        }</span>

        <span class="cov0" title="0">tenantID := req.Config["tenant_id"] // Optional

        // Initialize Azure credentials using DefaultAzureCredential
        // This supports multiple auth methods: MSI, Azure CLI, Environment Variables, etc.
        cred, err := azidentity.NewDefaultAzureCredential(&amp;azidentity.DefaultAzureCredentialOptions{
                TenantID: tenantID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return &amp;pb.InitializeResponse{
                        Success: false,
                        Error:   fmt.Sprintf("failed to create Azure credential: %v", err),
                }, nil
        }</span>

        <span class="cov0" title="0">p.credential = cred
        p.subscriptionID = subscriptionID
        p.tenantID = tenantID
        p.cacheDir = req.CacheDir

        // Initialize components
        p.discovery = NewAzureServiceDiscovery(cred, subscriptionID)
        p.scanner = NewAzureResourceScanner(cred, subscriptionID)
        p.schemaGen = NewAzureSchemaGenerator()
        p.clientFactory = NewAzureClientFactory(cred, subscriptionID)

        // Initialize database integration
        database, err := NewAzureDatabaseIntegration()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to initialize database integration: %v", err)
                // Continue without database integration
        }</span> else<span class="cov0" title="0"> {
                p.database = database
                log.Printf("Azure database integration initialized successfully")
        }</span>

        // Initialize Resource Graph client for efficient querying
        <span class="cov0" title="0">resourceGraph, err := NewResourceGraphClient(cred, []string{subscriptionID})
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to initialize Resource Graph client: %v", err)
                // Continue without Resource Graph - fall back to ARM APIs
        }</span> else<span class="cov0" title="0"> {
                p.resourceGraph = resourceGraph
                log.Printf("Resource Graph client initialized successfully")
        }</span>

        <span class="cov0" title="0">p.initialized = true

        return &amp;pb.InitializeResponse{
                Success: true,
                Version: "1.0.0",
                Metadata: map[string]string{
                        "subscription_id": subscriptionID,
                        "tenant_id":       tenantID,
                        "auth_method":     "DefaultAzureCredential",
                        "resource_graph":  fmt.Sprintf("%t", p.resourceGraph != nil),
                },
        }, nil</span>
}

// GetProviderInfo returns information about the Azure provider
func (p *AzureProvider) GetProviderInfo(ctx context.Context, req *pb.Empty) (*pb.ProviderInfoResponse, error) <span class="cov0" title="0">{
        return &amp;pb.ProviderInfoResponse{
                Name:        "azure",
                Version:     "1.0.0",
                Description: "Microsoft Azure cloud provider plugin with ARM integration and Resource Graph support",
                Capabilities: map[string]string{
                        "discovery":        "true",
                        "scanning":         "true",
                        "streaming":        "true",
                        "multi_region":     "true",
                        "resource_graph":   "true",
                        "change_tracking":  "true",
                        "batch_operations": "true",
                        "arm_integration":  "true",
                },
                SupportedServices: []string{
                        "compute", "storage", "network", "keyvault", "sql", "cosmosdb",
                        "appservice", "functions", "aks", "containerregistry", "monitor",
                },
        }, nil
}</span>

// DiscoverServices discovers available Azure services (resource providers)
func (p *AzureProvider) DiscoverServices(ctx context.Context, req *pb.DiscoverServicesRequest) (*pb.DiscoverServicesResponse, error) <span class="cov0" title="0">{
        if !p.initialized </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider not initialized")
        }</span>

        // Check cache unless force refresh is requested
        <span class="cov0" title="0">if !req.ForceRefresh </span><span class="cov0" title="0">{
                if cached := p.cache.GetServices(); cached != nil </span><span class="cov0" title="0">{
                        return &amp;pb.DiscoverServicesResponse{
                                Services:     cached,
                                DiscoveredAt: timestamppb.Now(),
                                SdkVersion:   "azure-sdk-go-v1.0.0",
                        }, nil
                }</span>
        }

        // Discover Azure resource providers
        <span class="cov0" title="0">providerInfos, err := p.discovery.DiscoverProviders(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to discover Azure providers: %w", err)
        }</span>

        // Convert to service list
        <span class="cov0" title="0">services := make([]*pb.ServiceInfo, 0, len(providerInfos))
        for _, providerInfo := range providerInfos </span><span class="cov0" title="0">{
                // Convert Microsoft.Compute -&gt; compute
                serviceName := p.normalizeServiceName(providerInfo.Namespace)

                // Skip if service is in exclude list
                if p.isServiceExcluded(serviceName, req.ExcludeServices) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Include only if in include list (if specified)
                <span class="cov0" title="0">if len(req.IncludeServices) &gt; 0 &amp;&amp; !p.isServiceIncluded(serviceName, req.IncludeServices) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">service := &amp;pb.ServiceInfo{
                        Name:        serviceName,
                        DisplayName: strings.Title(serviceName),
                        PackageName: fmt.Sprintf("github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/%s", serviceName),
                        ClientType:  fmt.Sprintf("%sClient", strings.Title(serviceName)),
                }

                // Add resource types
                for _, rt := range providerInfo.ResourceTypes </span><span class="cov0" title="0">{
                        resourceType := &amp;pb.ResourceType{
                                Name:              rt.ResourceType,
                                TypeName:          fmt.Sprintf("%s/%s", providerInfo.Namespace, rt.ResourceType),
                                ListOperation:     "List",
                                DescribeOperation: "Get",
                                GetOperation:      "Get",
                                IdField:           "id",
                                NameField:         "name",
                                SupportsTags:      true,
                                Paginated:         true,
                        }
                        service.ResourceTypes = append(service.ResourceTypes, resourceType)
                }</span>

                <span class="cov0" title="0">services = append(services, service)</span>
        }

        // Cache the results
        <span class="cov0" title="0">p.cache.SetServices(services)

        return &amp;pb.DiscoverServicesResponse{
                Services:     services,
                DiscoveredAt: timestamppb.Now(),
                SdkVersion:   "azure-sdk-go-v1.0.0",
        }, nil</span>
}

// ListResources lists resources for specified services
func (p *AzureProvider) ListResources(ctx context.Context, req *pb.ListResourcesRequest) (*pb.ListResourcesResponse, error) <span class="cov0" title="0">{
        if !p.initialized </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider not initialized")
        }</span>

        // Apply rate limiting
        <span class="cov0" title="0">if err := p.rateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rate limit exceeded: %w", err)
        }</span>

        <span class="cov0" title="0">var resources []*pb.ResourceRef
        filters := p.parseFilters(req.Filters)

        if req.Service != "" </span><span class="cov0" title="0">{
                // List resources for a specific service
                serviceResources, err := p.scanner.ScanService(ctx, req.Service, filters)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan service %s: %w", req.Service, err)
                }</span>
                <span class="cov0" title="0">resources = serviceResources</span>
        } else<span class="cov0" title="0"> {
                // List all resources - use Resource Graph for efficiency if available
                if p.resourceGraph != nil </span><span class="cov0" title="0">{
                        allResources, err := p.resourceGraph.QueryAllResources(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Resource Graph query failed, falling back to ARM: %v", err)
                                // Fall back to ARM scanning
                                allResources, err = p.scanner.ScanAllResources(ctx, filters)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to scan all resources: %w", err)
                                }</span>
                        }
                        <span class="cov0" title="0">resources = allResources</span>
                } else<span class="cov0" title="0"> {
                        // Use ARM scanning
                        allResources, err := p.scanner.ScanAllResources(ctx, filters)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to scan all resources: %w", err)
                        }</span>
                        <span class="cov0" title="0">resources = allResources</span>
                }
        }

        <span class="cov0" title="0">return &amp;pb.ListResourcesResponse{
                Resources: resources,
                Metadata: map[string]string{
                        "resource_count": fmt.Sprintf("%d", len(resources)),
                        "scan_time":      time.Now().Format(time.RFC3339),
                        "method":         p.getScanMethod(),
                },
        }, nil</span>
}

// BatchScan performs batch scanning of multiple services
func (p *AzureProvider) BatchScan(ctx context.Context, req *pb.BatchScanRequest) (*pb.BatchScanResponse, error) <span class="cov0" title="0">{
        if !p.initialized </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider not initialized")
        }</span>

        <span class="cov0" title="0">startTime := time.Now()
        var allResources []*pb.Resource
        var errors []string
        stats := &amp;pb.ScanStats{
                ResourceCounts: make(map[string]int32),
                ServiceCounts:  make(map[string]int32),
        }

        // Use Resource Graph for efficient batch scanning if available
        if p.resourceGraph != nil &amp;&amp; len(req.Services) &gt; 1 </span><span class="cov0" title="0">{
                resources, err := p.batchScanWithResourceGraph(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Resource Graph batch scan failed, falling back to ARM: %v", err)
                        // Fall back to ARM scanning
                        resources, err = p.batchScanWithARM(ctx, req)
                        if err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Sprintf("Batch scan failed: %v", err))
                        }</span> else<span class="cov0" title="0"> {
                                allResources = resources
                        }</span>
                } else<span class="cov0" title="0"> {
                        allResources = resources
                }</span>
        } else<span class="cov0" title="0"> {
                // Use ARM scanning
                resources, err := p.batchScanWithARM(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("Batch scan failed: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        allResources = resources
                }</span>
        }

        // Store resources in database if available
        <span class="cov0" title="0">if p.database != nil &amp;&amp; len(allResources) &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("Storing %d Azure resources in database", len(allResources))
                if err := p.database.StoreResources(allResources); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to store resources in database: %v", err)
                        errors = append(errors, fmt.Sprintf("Database storage failed: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("Successfully stored %d Azure resources in database", len(allResources))
                }</span>
        }

        // Calculate statistics
        <span class="cov0" title="0">stats.TotalResources = int32(len(allResources))
        stats.DurationMs = time.Since(startTime).Milliseconds()

        for _, resource := range allResources </span><span class="cov0" title="0">{
                stats.ResourceCounts[resource.Type]++
                stats.ServiceCounts[resource.Service]++
        }</span>

        <span class="cov0" title="0">return &amp;pb.BatchScanResponse{
                Resources: allResources,
                Stats:     stats,
                Errors:    errors,
        }, nil</span>
}

// StreamScan streams resources as they are discovered
func (p *AzureProvider) StreamScan(req *pb.StreamScanRequest, stream pb.CloudProvider_StreamScanServer) error <span class="cov0" title="0">{
        if !p.initialized </span><span class="cov0" title="0">{
                return fmt.Errorf("provider not initialized")
        }</span>

        <span class="cov0" title="0">ctx := stream.Context()
        resourceChan := make(chan *pb.Resource, 100)
        errChan := make(chan error, 1)

        // Start async scanning
        go func() </span><span class="cov0" title="0">{
                defer close(resourceChan)
                err := p.scanner.StreamScanResources(ctx, req.Services, resourceChan)
                if err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                }</span>
        }()

        // Stream resources as they come in
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case resource, ok := &lt;-resourceChan:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return nil // Scanning complete
                        }</span>
                        <span class="cov0" title="0">if err := stream.Send(resource); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to send resource: %w", err)
                        }</span>
                case err := &lt;-errChan:<span class="cov0" title="0">
                        return fmt.Errorf("scanning error: %w", err)</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                }
        }
}

// GetSchemas returns database schemas for resources
func (p *AzureProvider) GetSchemas(ctx context.Context, req *pb.GetSchemasRequest) (*pb.SchemaResponse, error) <span class="cov0" title="0">{
        if !p.initialized </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider not initialized")
        }</span>

        <span class="cov0" title="0">schemas := make([]*pb.Schema, 0)
        
        // Generate the main DuckDB schemas
        dbSchemas := GenerateAzureDuckDBSchemas()
        
        // Always include core tables
        // Add the main azure_resources table
        schemas = append(schemas, &amp;pb.Schema{
                Name:         "azure_resources",
                Service:      "core",
                ResourceType: "all",
                Sql:          dbSchemas.AzureResourcesTable,
                Description:  "Unified table for all Azure resources",
                Metadata: map[string]string{
                        "provider":     "azure",
                        "table_type":   "unified",
                        "supports_json": "true",
                },
        })
        
        // Add the relationships table
        schemas = append(schemas, &amp;pb.Schema{
                Name:         "azure_relationships",
                Service:      "core",
                ResourceType: "relationships",
                Sql:          dbSchemas.AzureRelationshipsTable,
                Description:  "Resource relationships and dependencies",
                Metadata: map[string]string{
                        "provider":     "azure",
                        "table_type":   "graph",
                        "supports_json": "true",
                },
        })
        
        // Add scan metadata table
        schemas = append(schemas, &amp;pb.Schema{
                Name:         "azure_scan_metadata",
                Service:      "core",
                ResourceType: "metadata",
                Sql:          dbSchemas.ScanMetadataTable,
                Description:  "Scan operation metadata and history",
                Metadata: map[string]string{
                        "provider":   "azure",
                        "table_type": "metadata",
                },
        })
        
        // Add API action metadata table
        schemas = append(schemas, &amp;pb.Schema{
                Name:         "azure_api_action_metadata",
                Service:      "core",
                ResourceType: "api_metadata",
                Sql:          dbSchemas.APIActionMetadataTable,
                Description:  "Azure API call tracking and performance",
                Metadata: map[string]string{
                        "provider":   "azure",
                        "table_type": "telemetry",
                },
        })

        // If specific services requested, also add service-specific schemas
        if len(req.Services) &gt; 0 </span><span class="cov0" title="0">{
                for _, service := range req.Services </span><span class="cov0" title="0">{
                        // Add predefined service-specific tables
                        switch service </span>{
                        case "storage":<span class="cov0" title="0">
                                if sql, exists := dbSchemas.ServiceTables["storage_accounts"]; exists </span><span class="cov0" title="0">{
                                        schemas = append(schemas, &amp;pb.Schema{
                                                Name:         "azure_storage_accounts",
                                                Service:      "storage",
                                                ResourceType: "Microsoft.Storage/storageAccounts",
                                                Sql:          sql,
                                                Description:  "Azure Storage Accounts with detailed properties",
                                                Metadata: map[string]string{
                                                        "provider":      "azure",
                                                        "table_type":    "service_specific",
                                                        "supports_json": "true",
                                                },
                                        })
                                }</span>
                        case "compute":<span class="cov0" title="0">
                                if sql, exists := dbSchemas.ServiceTables["virtual_machines"]; exists </span><span class="cov0" title="0">{
                                        schemas = append(schemas, &amp;pb.Schema{
                                                Name:         "azure_virtual_machines",
                                                Service:      "compute",
                                                ResourceType: "Microsoft.Compute/virtualMachines",
                                                Sql:          sql,
                                                Description:  "Azure Virtual Machines with detailed properties",
                                                Metadata: map[string]string{
                                                        "provider":      "azure",
                                                        "table_type":    "service_specific",
                                                        "supports_json": "true",
                                                },
                                        })
                                }</span>
                        case "network":<span class="cov0" title="0">
                                if sql, exists := dbSchemas.ServiceTables["virtual_networks"]; exists </span><span class="cov0" title="0">{
                                        schemas = append(schemas, &amp;pb.Schema{
                                                Name:         "azure_virtual_networks",
                                                Service:      "network",
                                                ResourceType: "Microsoft.Network/virtualNetworks",
                                                Sql:          sql,
                                                Description:  "Azure Virtual Networks with detailed properties",
                                                Metadata: map[string]string{
                                                        "provider":      "azure",
                                                        "table_type":    "service_specific",
                                                        "supports_json": "true",
                                                },
                                        })
                                }</span>
                        case "keyvault":<span class="cov0" title="0">
                                if sql, exists := dbSchemas.ServiceTables["key_vaults"]; exists </span><span class="cov0" title="0">{
                                        schemas = append(schemas, &amp;pb.Schema{
                                                Name:         "azure_key_vaults",
                                                Service:      "keyvault",
                                                ResourceType: "Microsoft.KeyVault/vaults",
                                                Sql:          sql,
                                                Description:  "Azure Key Vaults with detailed properties",
                                                Metadata: map[string]string{
                                                        "provider":      "azure",
                                                        "table_type":    "service_specific",
                                                        "supports_json": "true",
                                                },
                                        })
                                }</span>
                        }
                        
                        // Also try to get dynamic schemas for the service
                        <span class="cov0" title="0">provider := p.discovery.GetProvider(p.denormalizeServiceName(service))
                        if provider != nil </span><span class="cov0" title="0">{
                                for _, resourceType := range provider.ResourceTypes </span><span class="cov0" title="0">{
                                        schema := p.schemaGen.GenerateSchema(resourceType)
                                        pbSchema := &amp;pb.Schema{
                                                Name:         schema.TableName,
                                                Service:      service,
                                                ResourceType: resourceType.ResourceType,
                                                Sql:          p.generateCreateTableSQL(schema),
                                                Description:  fmt.Sprintf("Dynamic schema for %s resources", resourceType.ResourceType),
                                                Metadata: map[string]string{
                                                        "provider":     "azure",
                                                        "api_version":  resourceType.APIVersions[0],
                                                        "column_count": fmt.Sprintf("%d", len(schema.Columns)),
                                                        "has_indexes":  fmt.Sprintf("%t", len(schema.Indexes) &gt; 0),
                                                        "table_type":   "dynamic",
                                                },
                                        }
                                        schemas = append(schemas, pbSchema)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return &amp;pb.SchemaResponse{
                Schemas: schemas,
        }, nil</span>
}

// DescribeResource provides detailed information about a specific resource
func (p *AzureProvider) DescribeResource(ctx context.Context, req *pb.DescribeResourceRequest) (*pb.DescribeResourceResponse, error) <span class="cov0" title="0">{
        if !p.initialized </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider not initialized")
        }</span>

        <span class="cov0" title="0">resourceRef := req.ResourceRef
        if resourceRef == nil </span><span class="cov0" title="0">{
                return &amp;pb.DescribeResourceResponse{
                        Error: "resource_ref is required",
                }, nil
        }</span>

        // Get detailed resource information
        <span class="cov0" title="0">resource, err := p.scanner.DescribeResource(ctx, resourceRef)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;pb.DescribeResourceResponse{
                        Error: fmt.Sprintf("failed to describe resource: %v", err),
                }, nil
        }</span>

        // Add relationships if requested
        <span class="cov0" title="0">if req.IncludeRelationships &amp;&amp; p.resourceGraph != nil </span><span class="cov0" title="0">{
                relationships, err := p.resourceGraph.QueryResourceRelationships(ctx, resourceRef.Id)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to query relationships for %s: %v", resourceRef.Id, err)
                }</span> else<span class="cov0" title="0"> {
                        for _, rel := range relationships </span><span class="cov0" title="0">{
                                resource.Relationships = append(resource.Relationships, &amp;pb.Relationship{
                                        TargetId:         rel.TargetID,
                                        TargetType:       rel.RelationType,
                                        RelationshipType: rel.Direction,
                                })
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;pb.DescribeResourceResponse{
                Resource: resource,
        }, nil</span>
}

// GenerateServiceScanners generates service-specific scanners (placeholder for future implementation)
func (p *AzureProvider) GenerateServiceScanners(ctx context.Context, req *pb.GenerateScannersRequest) (*pb.GenerateScannersResponse, error) <span class="cov0" title="0">{
        // This would generate service-specific scanners similar to AWS
        // For now, return empty response as Azure uses dynamic scanning
        return &amp;pb.GenerateScannersResponse{
                Scanners:       []*pb.GeneratedScanner{},
                GeneratedCount: 0,
        }, nil
}</span>

// Helper methods

func (p *AzureProvider) normalizeServiceName(namespace string) string <span class="cov0" title="0">{
        // Convert Microsoft.Compute -&gt; compute
        return strings.ToLower(strings.TrimPrefix(namespace, "Microsoft."))
}</span>

func (p *AzureProvider) denormalizeServiceName(service string) string <span class="cov0" title="0">{
        // Convert compute -&gt; Microsoft.Compute
        return fmt.Sprintf("Microsoft.%s", strings.Title(service))
}</span>

func (p *AzureProvider) parseFilters(filters map[string]string) map[string]string <span class="cov0" title="0">{
        // Azure-specific filter parsing
        result := make(map[string]string)
        for k, v := range filters </span><span class="cov0" title="0">{
                switch k </span>{
                case "resource_group", "location", "tag":<span class="cov0" title="0">
                        result[k] = v</span>
                default:<span class="cov0" title="0">
                        result[k] = v</span>
                }
        }
        <span class="cov0" title="0">return result</span>
}

func (p *AzureProvider) isServiceExcluded(service string, excludeList []string) bool <span class="cov0" title="0">{
        for _, excluded := range excludeList </span><span class="cov0" title="0">{
                if service == excluded </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (p *AzureProvider) isServiceIncluded(service string, includeList []string) bool <span class="cov0" title="0">{
        for _, included := range includeList </span><span class="cov0" title="0">{
                if service == included </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (p *AzureProvider) getScanMethod() string <span class="cov0" title="0">{
        if p.resourceGraph != nil </span><span class="cov0" title="0">{
                return "resource_graph"
        }</span>
        <span class="cov0" title="0">return "arm_api"</span>
}

func (p *AzureProvider) batchScanWithResourceGraph(ctx context.Context, req *pb.BatchScanRequest) ([]*pb.Resource, error) <span class="cov0" title="0">{
        // Use Resource Graph for efficient batch scanning
        filters := make(map[string]interface{})

        if len(req.Services) &gt; 0 </span><span class="cov0" title="0">{
                // Map service names to actual Azure resource types
                serviceMapping := map[string][]string{
                        "storage":         {"microsoft.storage/storageaccounts"},
                        "compute":         {"microsoft.compute/virtualmachines", "microsoft.compute/disks", "microsoft.compute/virtualmachinescalesets"},
                        "network":         {"microsoft.network/virtualnetworks", "microsoft.network/networkinterfaces", "microsoft.network/publicipaddresses", "microsoft.network/privatednszones", "microsoft.network/networksecuritygroups"},
                        "keyvault":        {"microsoft.keyvault/vaults"},
                        "sql":             {"microsoft.sql/servers", "microsoft.sql/servers/databases"},
                        "cosmosdb":        {"microsoft.documentdb/databaseaccounts"},
                        "appservice":      {"microsoft.web/sites", "microsoft.web/serverfarms"},
                        "functions":       {"microsoft.web/sites"},
                        "aks":             {"microsoft.containerservice/managedclusters"},
                        "containerregistry": {"microsoft.containerregistry/registries"},
                        "monitor":         {"microsoft.insights/components", "microsoft.operationalinsights/workspaces"},
                        "eventhub":        {"microsoft.eventhub/namespaces"},
                        "managedidentity": {"microsoft.managedidentity/userassignedidentities"},
                }
                
                var resourceTypes []string
                for _, service := range req.Services </span><span class="cov0" title="0">{
                        if types, ok := serviceMapping[strings.ToLower(service)]; ok </span><span class="cov0" title="0">{
                                resourceTypes = append(resourceTypes, types...)
                        }</span> else<span class="cov0" title="0"> {
                                // If not in mapping, try generic pattern
                                resourceTypes = append(resourceTypes, fmt.Sprintf("microsoft.%s/*", strings.ToLower(service)))
                        }</span>
                }
                
                <span class="cov0" title="0">if len(resourceTypes) &gt; 0 </span><span class="cov0" title="0">{
                        filters["type"] = resourceTypes
                }</span>
        }

        // Only add region filter if it's not the default AWS region
        <span class="cov0" title="0">if req.Region != "" &amp;&amp; req.Region != "us-east-1" </span><span class="cov0" title="0">{
                filters["location"] = req.Region
        }</span>

        // Add custom filters
        <span class="cov0" title="0">for k, v := range req.Filters </span><span class="cov0" title="0">{
                filters[k] = v
        }</span>

        <span class="cov0" title="0">log.Printf("Resource Graph query filters: %+v", filters)
        resourceRefs, err := p.resourceGraph.QueryResourcesWithFilter(ctx, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resource graph query failed: %w", err)
        }</span>
        <span class="cov0" title="0">log.Printf("Resource Graph returned %d resources", len(resourceRefs))

        // Convert ResourceRef to Resource
        resources := make([]*pb.Resource, 0, len(resourceRefs))
        for _, ref := range resourceRefs </span><span class="cov0" title="0">{
                resource := &amp;pb.Resource{
                        Provider:     "azure",
                        Service:      ref.Service,
                        Type:         ref.Type,
                        Id:           ref.Id,
                        Name:         ref.Name,
                        Region:       ref.Region,
                        Tags:         make(map[string]string),
                        DiscoveredAt: timestamppb.Now(),
                }

                // Extract metadata
                if ref.BasicAttributes != nil </span><span class="cov0" title="0">{
                        if rg, ok := ref.BasicAttributes["resource_group"]; ok </span><span class="cov0" title="0">{
                                resource.ParentId = rg
                        }</span>
                        <span class="cov0" title="0">if subID, ok := ref.BasicAttributes["subscription_id"]; ok </span><span class="cov0" title="0">{
                                resource.AccountId = subID
                        }</span>

                        // Extract tags
                        <span class="cov0" title="0">for k, v := range ref.BasicAttributes </span><span class="cov0" title="0">{
                                if strings.HasPrefix(k, "tag_") </span><span class="cov0" title="0">{
                                        tagName := strings.TrimPrefix(k, "tag_")
                                        resource.Tags[tagName] = v
                                }</span>
                        }

                        // Store properties as raw data
                        <span class="cov0" title="0">if props, ok := ref.BasicAttributes["properties"]; ok </span><span class="cov0" title="0">{
                                resource.RawData = props
                        }</span>
                }

                <span class="cov0" title="0">resources = append(resources, resource)</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

func (p *AzureProvider) batchScanWithARM(ctx context.Context, req *pb.BatchScanRequest) ([]*pb.Resource, error) <span class="cov0" title="0">{
        // Fall back to ARM API scanning
        var allResources []*pb.Resource
        
        log.Printf("Batch scanning %d services: %v", len(req.Services), req.Services)

        // Clean up filters - remove AWS default region
        cleanFilters := make(map[string]string)
        for k, v := range req.Filters </span><span class="cov0" title="0">{
                if k == "region" &amp;&amp; v == "us-east-1" </span><span class="cov0" title="0">{
                        continue</span> // Skip AWS default region
                }
                <span class="cov0" title="0">cleanFilters[k] = v</span>
        }
        
        <span class="cov0" title="0">for _, service := range req.Services </span><span class="cov0" title="0">{
                log.Printf("Scanning service: %s", service)
                resources, err := p.scanner.ScanServiceForResources(ctx, service, cleanFilters)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to scan service %s: %v", service, err)
                        continue</span>
                }
                <span class="cov0" title="0">log.Printf("Found %d resources for service %s", len(resources), service)
                allResources = append(allResources, resources...)</span>
        }

        <span class="cov0" title="0">log.Printf("Total resources found in batch scan: %d", len(allResources))
        return allResources, nil</span>
}

func (p *AzureProvider) generateCreateTableSQL(schema *TableSchema) string <span class="cov0" title="0">{
        var columns []string
        for _, col := range schema.Columns </span><span class="cov0" title="0">{
                nullable := ""
                if col.Nullable </span><span class="cov0" title="0">{
                        nullable = " NULL"
                }</span> else<span class="cov0" title="0"> {
                        nullable = " NOT NULL"
                }</span>

                <span class="cov0" title="0">pk := ""
                if col.PrimaryKey </span><span class="cov0" title="0">{
                        pk = " PRIMARY KEY"
                }</span>

                <span class="cov0" title="0">columns = append(columns, fmt.Sprintf("  %s %s%s%s", col.Name, col.Type, nullable, pk))</span>
        }

        <span class="cov0" title="0">sql := fmt.Sprintf("CREATE TABLE %s (\n%s\n);", schema.TableName, strings.Join(columns, ",\n"))

        // Add indexes
        for _, index := range schema.Indexes </span><span class="cov0" title="0">{
                sql += fmt.Sprintf("\nCREATE INDEX %s ON %s (%s);", index, schema.TableName, index)
        }</span>

        <span class="cov0" title="0">return sql</span>
}

// ConfigureDiscovery configures the auto-discovery system
func (p *AzureProvider) ConfigureDiscovery(ctx context.Context, req *pb.ConfigureDiscoveryRequest) (*pb.ConfigureDiscoveryResponse, error) <span class="cov0" title="0">{
        if !p.initialized </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider not initialized")
        }</span>

        // Simple implementation for now
        <span class="cov0" title="0">return &amp;pb.ConfigureDiscoveryResponse{
                Success: true,
        }, nil</span>
}

// AnalyzeDiscoveredData analyzes discovered Azure resources and generates insights
func (p *AzureProvider) AnalyzeDiscoveredData(ctx context.Context, req *pb.AnalyzeRequest) (*pb.AnalysisResponse, error) <span class="cov0" title="0">{
        if !p.initialized </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider not initialized")
        }</span>

        // Simple implementation for now
        <span class="cov0" title="0">return &amp;pb.AnalysisResponse{
                Success: true,
        }, nil</span>
}

// GenerateFromAnalysis generates scanners or configurations based on analysis results
func (p *AzureProvider) GenerateFromAnalysis(ctx context.Context, req *pb.GenerateFromAnalysisRequest) (*pb.GenerateResponse, error) <span class="cov0" title="0">{
        if !p.initialized </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider not initialized")
        }</span>

        // Simple implementation for now
        <span class="cov0" title="0">return &amp;pb.GenerateResponse{
                Success: true,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "strings"
        "sync"

        "github.com/Azure/azure-sdk-for-go/sdk/azcore"
        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v6"
        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/network/armnetwork/v6"
        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/resources/armresources"
        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/storage/armstorage"
)

// AzureClientFactory creates SDK clients dynamically
type AzureClientFactory struct {
        credential     azcore.TokenCredential
        subscriptionID string
        clientCache    map[string]interface{}
        mu             sync.RWMutex
}

// NewAzureClientFactory creates a new Azure client factory
func NewAzureClientFactory(cred azcore.TokenCredential, subID string) *AzureClientFactory <span class="cov0" title="0">{
        return &amp;AzureClientFactory{
                credential:     cred,
                subscriptionID: subID,
                clientCache:    make(map[string]interface{}),
        }
}</span>

// GetClient returns a client for the specified resource type
func (f *AzureClientFactory) GetClient(resourceType string) (interface{}, error) <span class="cov0" title="0">{
        f.mu.RLock()
        if client, exists := f.clientCache[resourceType]; exists </span><span class="cov0" title="0">{
                f.mu.RUnlock()
                return client, nil
        }</span>
        <span class="cov0" title="0">f.mu.RUnlock()

        // Create client based on resource type
        f.mu.Lock()
        defer f.mu.Unlock()

        // Double-check after acquiring write lock
        if client, exists := f.clientCache[resourceType]; exists </span><span class="cov0" title="0">{
                return client, nil
        }</span>

        <span class="cov0" title="0">client, err := f.createClient(resourceType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">f.clientCache[resourceType] = client
        return client, nil</span>
}

// createClient creates a client based on resource type
func (f *AzureClientFactory) createClient(resourceType string) (interface{}, error) <span class="cov0" title="0">{
        // Map resource types to SDK clients
        switch resourceType </span>{
        case "Microsoft.Compute/virtualMachines":<span class="cov0" title="0">
                return armcompute.NewVirtualMachinesClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Compute/virtualMachineScaleSets":<span class="cov0" title="0">
                return armcompute.NewVirtualMachineScaleSetsClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Compute/disks":<span class="cov0" title="0">
                return armcompute.NewDisksClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Compute/snapshots":<span class="cov0" title="0">
                return armcompute.NewSnapshotsClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Compute/images":<span class="cov0" title="0">
                return armcompute.NewImagesClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Compute/availabilitySets":<span class="cov0" title="0">
                return armcompute.NewAvailabilitySetsClient(f.subscriptionID, f.credential, nil)</span>

        case "Microsoft.Storage/storageAccounts":<span class="cov0" title="0">
                return armstorage.NewAccountsClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Storage/storageAccounts/blobServices":<span class="cov0" title="0">
                return armstorage.NewBlobServicesClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Storage/storageAccounts/fileServices":<span class="cov0" title="0">
                return armstorage.NewFileServicesClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Storage/storageAccounts/queueServices":<span class="cov0" title="0">
                return armstorage.NewQueueServicesClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Storage/storageAccounts/tableServices":<span class="cov0" title="0">
                return armstorage.NewTableServicesClient(f.subscriptionID, f.credential, nil)</span>

        case "Microsoft.Network/virtualNetworks":<span class="cov0" title="0">
                return armnetwork.NewVirtualNetworksClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Network/networkSecurityGroups":<span class="cov0" title="0">
                return armnetwork.NewSecurityGroupsClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Network/publicIPAddresses":<span class="cov0" title="0">
                return armnetwork.NewPublicIPAddressesClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Network/networkInterfaces":<span class="cov0" title="0">
                return armnetwork.NewInterfacesClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Network/loadBalancers":<span class="cov0" title="0">
                return armnetwork.NewLoadBalancersClient(f.subscriptionID, f.credential, nil)</span>
        case "Microsoft.Network/applicationGateways":<span class="cov0" title="0">
                return armnetwork.NewApplicationGatewaysClient(f.subscriptionID, f.credential, nil)</span>

        default:<span class="cov0" title="0">
                // For unknown types, return the generic resources client
                return armresources.NewClient(f.subscriptionID, f.credential, nil)</span>
        }
}

// GetComputeClient returns a compute client
func (f *AzureClientFactory) GetComputeClient() (*armcompute.VirtualMachinesClient, error) <span class="cov0" title="0">{
        client, err := f.GetClient("Microsoft.Compute/virtualMachines")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client.(*armcompute.VirtualMachinesClient), nil</span>
}

// GetStorageClient returns a storage client
func (f *AzureClientFactory) GetStorageClient() (*armstorage.AccountsClient, error) <span class="cov0" title="0">{
        client, err := f.GetClient("Microsoft.Storage/storageAccounts")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client.(*armstorage.AccountsClient), nil</span>
}

// GetNetworkClient returns a network client
func (f *AzureClientFactory) GetNetworkClient() (*armnetwork.VirtualNetworksClient, error) <span class="cov0" title="0">{
        client, err := f.GetClient("Microsoft.Network/virtualNetworks")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client.(*armnetwork.VirtualNetworksClient), nil</span>
}

// GetResourcesClient returns the generic resources client
func (f *AzureClientFactory) GetResourcesClient() (*armresources.Client, error) <span class="cov0" title="0">{
        client, err := f.GetClient("Microsoft.Resources/resources")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client.(*armresources.Client), nil</span>
}

// ClearCache clears the client cache
func (f *AzureClientFactory) ClearCache() <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()
        f.clientCache = make(map[string]interface{})
}</span>

// GetCacheSize returns the number of cached clients
func (f *AzureClientFactory) GetCacheSize() int <span class="cov0" title="0">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        return len(f.clientCache)
}</span>

// GetCachedClientTypes returns the types of cached clients
func (f *AzureClientFactory) GetCachedClientTypes() []string <span class="cov0" title="0">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        types := make([]string, 0, len(f.clientCache))
        for resourceType := range f.clientCache </span><span class="cov0" title="0">{
                types = append(types, resourceType)
        }</span>
        <span class="cov0" title="0">return types</span>
}

// ValidateClient validates that a client can be created for a resource type
func (f *AzureClientFactory) ValidateClient(resourceType string) error <span class="cov0" title="0">{
        _, err := f.createClient(resourceType)
        return err
}</span>

// GetSupportedResourceTypes returns the resource types that have specific client implementations
func (f *AzureClientFactory) GetSupportedResourceTypes() []string <span class="cov0" title="0">{
        return []string{
                "Microsoft.Compute/virtualMachines",
                "Microsoft.Compute/virtualMachineScaleSets",
                "Microsoft.Compute/disks",
                "Microsoft.Compute/snapshots",
                "Microsoft.Compute/images",
                "Microsoft.Compute/availabilitySets",
                "Microsoft.Storage/storageAccounts",
                "Microsoft.Storage/storageAccounts/blobServices",
                "Microsoft.Storage/storageAccounts/fileServices",
                "Microsoft.Storage/storageAccounts/queueServices",
                "Microsoft.Storage/storageAccounts/tableServices",
                "Microsoft.Network/virtualNetworks",
                "Microsoft.Network/networkSecurityGroups",
                "Microsoft.Network/publicIPAddresses",
                "Microsoft.Network/networkInterfaces",
                "Microsoft.Network/loadBalancers",
                "Microsoft.Network/applicationGateways",
        }
}</span>

// IsResourceTypeSupported checks if a resource type has a specific client implementation
func (f *AzureClientFactory) IsResourceTypeSupported(resourceType string) bool <span class="cov0" title="0">{
        supported := f.GetSupportedResourceTypes()
        for _, supportedType := range supported </span><span class="cov0" title="0">{
                if supportedType == resourceType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetClientStatistics returns statistics about client usage
func (f *AzureClientFactory) GetClientStatistics() map[string]interface{} <span class="cov0" title="0">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        stats := make(map[string]interface{})
        stats["total_cached_clients"] = len(f.clientCache)
        stats["subscription_id"] = f.subscriptionID

        // Group by service
        serviceGroups := make(map[string]int)
        for resourceType := range f.clientCache </span><span class="cov0" title="0">{
                service := extractServiceFromResourceType(resourceType)
                serviceGroups[service]++
        }</span>
        <span class="cov0" title="0">stats["clients_by_service"] = serviceGroups

        return stats</span>
}

// extractServiceFromResourceType extracts service name from resource type
func extractServiceFromResourceType(resourceType string) string <span class="cov0" title="0">{
        // Microsoft.Compute/virtualMachines -&gt; Compute
        parts := strings.Split(resourceType, "/")
        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                provider := parts[0]
                return strings.TrimPrefix(provider, "Microsoft.")
        }</span>
        <span class="cov0" title="0">return "Unknown"</span>
}

// RefreshClient removes a client from cache to force recreation
func (f *AzureClientFactory) RefreshClient(resourceType string) <span class="cov0" title="0">{
        f.mu.Lock()
        defer f.mu.Unlock()
        delete(f.clientCache, resourceType)
}</span>

// GetClientInfo returns information about a specific client
func (f *AzureClientFactory) GetClientInfo(resourceType string) map[string]interface{} <span class="cov0" title="0">{
        f.mu.RLock()
        defer f.mu.RUnlock()

        info := make(map[string]interface{})
        info["resource_type"] = resourceType
        info["subscription_id"] = f.subscriptionID
        info["is_cached"] = f.clientCache[resourceType] != nil
        info["is_supported"] = f.IsResourceTypeSupported(resourceType)

        return info
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"
        "time"

        _ "github.com/marcboeker/go-duckdb"  // DuckDB driver
        pb "github.com/jlgore/corkscrew/internal/proto"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// AzureDatabaseIntegration handles database operations for Azure resources
type AzureDatabaseIntegration struct {
        db             *sql.DB
        dbPath         string
        insertResource *sql.Stmt
        insertRelation *sql.Stmt
}

// NewAzureDatabaseIntegration creates a new Azure database integration
func NewAzureDatabaseIntegration() (*AzureDatabaseIntegration, error) <span class="cov0" title="0">{
        // Use unified database path
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get home directory: %w", err)
        }</span>
        
        <span class="cov0" title="0">dbPath := filepath.Join(homeDir, ".corkscrew", "db", "corkscrew.duckdb")
        
        // Create directory if it doesn't exist
        if err := os.MkdirAll(filepath.Dir(dbPath), 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create database directory: %w", err)
        }</span>
        
        // Open database connection
        <span class="cov0" title="0">db, err := sql.Open("duckdb", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>
        
        // Install and load JSON extension
        <span class="cov0" title="0">if _, err := db.Exec("INSTALL json; LOAD json;"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load JSON extension: %w", err)
        }</span>
        
        <span class="cov0" title="0">integration := &amp;AzureDatabaseIntegration{
                db:     db,
                dbPath: dbPath,
        }
        
        // Initialize Azure tables
        if err := integration.initializeTables(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize tables: %w", err)
        }</span>
        
        // Prepare statements
        <span class="cov0" title="0">if err := integration.prepareStatements(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to prepare statements: %w", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("Azure database integration initialized at: %s", dbPath)
        return integration, nil</span>
}

// initializeTables creates the Azure resources table if it doesn't exist
func (d *AzureDatabaseIntegration) initializeTables() error <span class="cov0" title="0">{
        azureTableSQL := `
CREATE TABLE IF NOT EXISTS azure_resources (
    -- Primary identifiers
    id VARCHAR PRIMARY KEY,                    -- Azure Resource ID (full path)
    name VARCHAR NOT NULL,                     -- Resource name
    type VARCHAR NOT NULL,                     -- Resource type (e.g., Microsoft.Storage/storageAccounts)
    
    -- Azure-specific identifiers
    resource_id VARCHAR,                       -- Short resource ID
    subscription_id VARCHAR NOT NULL,          -- Azure subscription ID
    resource_group VARCHAR NOT NULL,           -- Resource group name
    
    -- Location and hierarchy
    location VARCHAR NOT NULL,                 -- Azure region (e.g., centralus)
    parent_id VARCHAR,                         -- Parent resource ID for hierarchical resources
    managed_by VARCHAR,                        -- ID of resource managing this resource
    
    -- Service information
    service VARCHAR,                           -- Service name (e.g., storage, compute)
    kind VARCHAR,                              -- Resource kind (e.g., StorageV2)
    
    -- SKU information
    sku_name VARCHAR,                          -- SKU name (e.g., Standard_LRS)
    sku_tier VARCHAR,                          -- SKU tier (e.g., Standard)
    sku_size VARCHAR,                          -- SKU size
    sku_family VARCHAR,                        -- SKU family
    sku_capacity INTEGER,                      -- SKU capacity
    
    -- Metadata
    tags JSON,                                 -- Resource tags
    properties JSON,                           -- Resource-specific properties
    raw_data JSON,                             -- Complete raw resource data
    
    -- State information
    provisioning_state VARCHAR,                -- Current provisioning state
    power_state VARCHAR,                       -- Power state (for VMs)
    
    -- Timestamps
    created_time TIMESTAMP,                    -- Resource creation time
    changed_time TIMESTAMP,                    -- Last modification time
    scanned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- When we discovered this resource
    
    -- Additional metadata
    etag VARCHAR,                              -- Entity tag for optimistic concurrency
    api_version VARCHAR                        -- API version used to fetch this resource
);`

        if _, err := d.db.Exec(azureTableSQL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create azure_resources table: %w", err)
        }</span>

        // Create indexes
        <span class="cov0" title="0">indexes := []string{
                "CREATE INDEX IF NOT EXISTS idx_azure_type ON azure_resources(type)",
                "CREATE INDEX IF NOT EXISTS idx_azure_service ON azure_resources(service)",
                "CREATE INDEX IF NOT EXISTS idx_azure_resource_group ON azure_resources(resource_group)",
                "CREATE INDEX IF NOT EXISTS idx_azure_location ON azure_resources(location)",
                "CREATE INDEX IF NOT EXISTS idx_azure_subscription_id ON azure_resources(subscription_id)",
                "CREATE INDEX IF NOT EXISTS idx_azure_parent_id ON azure_resources(parent_id)",
                "CREATE INDEX IF NOT EXISTS idx_azure_provisioning_state ON azure_resources(provisioning_state)",
                "CREATE INDEX IF NOT EXISTS idx_azure_scanned_at ON azure_resources(scanned_at)",
        }

        for _, indexSQL := range indexes </span><span class="cov0" title="0">{
                if _, err := d.db.Exec(indexSQL); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to create index: %v", err)
                }</span>
        }

        // Create unified relationships table if it doesn't exist
        <span class="cov0" title="0">relationshipsSQL := `
CREATE TABLE IF NOT EXISTS cloud_relationships (
    -- Relationship identifiers
    from_id VARCHAR NOT NULL,                  -- Source resource ID
    to_id VARCHAR NOT NULL,                    -- Target resource ID
    relationship_type VARCHAR NOT NULL,        -- Type of relationship
    
    -- Cloud provider context
    provider VARCHAR NOT NULL,                 -- Cloud provider (aws, azure, gcp, etc.)
    
    -- Relationship metadata
    relationship_subtype VARCHAR,              -- More specific relationship type
    properties JSON,                           -- Additional relationship properties
    
    -- Resource type context
    from_resource_type VARCHAR,                -- Source resource type
    to_resource_type VARCHAR,                  -- Target resource type
    direction VARCHAR DEFAULT 'outbound',      -- Relationship direction
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    discovered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Constraints
    PRIMARY KEY (from_id, to_id, relationship_type, provider)
);`

        if _, err := d.db.Exec(relationshipsSQL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create cloud_relationships table: %w", err)
        }</span>

        // Create relationship indexes
        <span class="cov0" title="0">relIndexes := []string{
                "CREATE INDEX IF NOT EXISTS idx_rel_from_id ON cloud_relationships(from_id)",
                "CREATE INDEX IF NOT EXISTS idx_rel_to_id ON cloud_relationships(to_id)",
                "CREATE INDEX IF NOT EXISTS idx_rel_type ON cloud_relationships(relationship_type)",
                "CREATE INDEX IF NOT EXISTS idx_rel_provider ON cloud_relationships(provider)",
                "CREATE INDEX IF NOT EXISTS idx_rel_from_type ON cloud_relationships(from_resource_type)",
                "CREATE INDEX IF NOT EXISTS idx_rel_to_type ON cloud_relationships(to_resource_type)",
        }

        for _, indexSQL := range relIndexes </span><span class="cov0" title="0">{
                if _, err := d.db.Exec(indexSQL); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to create relationship index: %v", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// prepareStatements prepares commonly used SQL statements
func (d *AzureDatabaseIntegration) prepareStatements() error <span class="cov0" title="0">{
        // Prepare resource insert statement
        insertResourceSQL := `
INSERT OR REPLACE INTO azure_resources (
    id, name, type, resource_id, subscription_id, resource_group,
    location, parent_id, managed_by, service, kind,
    sku_name, sku_tier, sku_size, sku_family, sku_capacity,
    tags, properties, raw_data, provisioning_state, power_state,
    created_time, changed_time, etag, api_version
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`

        var err error
        d.insertResource, err = d.db.Prepare(insertResourceSQL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare insert resource statement: %w", err)
        }</span>

        // Prepare relationship insert statement
        <span class="cov0" title="0">insertRelationSQL := `
INSERT OR REPLACE INTO cloud_relationships (
    from_id, to_id, relationship_type, provider, relationship_subtype,
    properties, from_resource_type, to_resource_type, direction
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`

        d.insertRelation, err = d.db.Prepare(insertRelationSQL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to prepare insert relationship statement: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// StoreResource stores an Azure resource in the database
func (d *AzureDatabaseIntegration) StoreResource(resource *pb.Resource) error <span class="cov0" title="0">{
        if d.insertResource == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database not properly initialized")
        }</span>

        // Convert tags to JSON
        <span class="cov0" title="0">tagsJSON, err := json.Marshal(resource.Tags)
        if err != nil || resource.Tags == nil </span><span class="cov0" title="0">{
                tagsJSON = []byte("{}")
        }</span>

        // Parse raw data to extract properties and other fields
        <span class="cov0" title="0">var properties map[string]interface{}
        var createdTime, changedTime *time.Time
        var etag, apiVersion string
        var skuInfo map[string]interface{}

        if resource.RawData != "" </span><span class="cov0" title="0">{
                var rawDataMap map[string]interface{}
                if err := json.Unmarshal([]byte(resource.RawData), &amp;rawDataMap); err == nil </span><span class="cov0" title="0">{
                        // Extract properties
                        if props, ok := rawDataMap["properties"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                properties = props
                        }</span>

                        // Extract timestamps
                        <span class="cov0" title="0">if ct, ok := rawDataMap["createdTime"].(string); ok </span><span class="cov0" title="0">{
                                if parsed, err := time.Parse(time.RFC3339, ct); err == nil </span><span class="cov0" title="0">{
                                        createdTime = &amp;parsed
                                }</span>
                        }
                        <span class="cov0" title="0">if ct, ok := rawDataMap["changedTime"].(string); ok </span><span class="cov0" title="0">{
                                if parsed, err := time.Parse(time.RFC3339, ct); err == nil </span><span class="cov0" title="0">{
                                        changedTime = &amp;parsed
                                }</span>
                        }

                        // Extract etag and API version
                        <span class="cov0" title="0">if e, ok := rawDataMap["etag"].(string); ok </span><span class="cov0" title="0">{
                                etag = e
                        }</span>
                        <span class="cov0" title="0">if av, ok := rawDataMap["apiVersion"].(string); ok </span><span class="cov0" title="0">{
                                apiVersion = av
                        }</span>

                        // Extract SKU information
                        <span class="cov0" title="0">if sku, ok := rawDataMap["sku"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                skuInfo = sku
                        }</span>
                }
        }

        // Convert properties to JSON
        <span class="cov0" title="0">propertiesJSON, err := json.Marshal(properties)
        if err != nil || properties == nil </span><span class="cov0" title="0">{
                propertiesJSON = []byte("{}")
        }</span>

        // Extract SKU fields
        <span class="cov0" title="0">var skuName, skuTier, skuSize, skuFamily string
        var skuCapacity *int
        if skuInfo != nil </span><span class="cov0" title="0">{
                if name, ok := skuInfo["name"].(string); ok </span><span class="cov0" title="0">{
                        skuName = name
                }</span>
                <span class="cov0" title="0">if tier, ok := skuInfo["tier"].(string); ok </span><span class="cov0" title="0">{
                        skuTier = tier
                }</span>
                <span class="cov0" title="0">if size, ok := skuInfo["size"].(string); ok </span><span class="cov0" title="0">{
                        skuSize = size
                }</span>
                <span class="cov0" title="0">if family, ok := skuInfo["family"].(string); ok </span><span class="cov0" title="0">{
                        skuFamily = family
                }</span>
                <span class="cov0" title="0">if capacity, ok := skuInfo["capacity"].(float64); ok </span><span class="cov0" title="0">{
                        cap := int(capacity)
                        skuCapacity = &amp;cap
                }</span>
        }

        // Handle empty RawData
        <span class="cov0" title="0">rawData := resource.RawData
        if rawData == "" </span><span class="cov0" title="0">{
                rawData = "{}"
        }</span>

        // Extract resource group from resource ID
        <span class="cov0" title="0">resourceGroup := extractResourceGroupFromID(resource.Id)
        if resourceGroup == "" </span><span class="cov0" title="0">{
                resourceGroup = resource.ParentId
        }</span>

        // Execute insert
        <span class="cov0" title="0">_, err = d.insertResource.Exec(
                resource.Id,                    // id
                resource.Name,                  // name
                resource.Type,                  // type
                resource.Id,                    // resource_id (same as id for now)
                resource.AccountId,             // subscription_id
                resourceGroup,                  // resource_group
                resource.Region,                // location
                resource.ParentId,              // parent_id
                nil,                           // managed_by
                resource.Service,               // service
                nil,                           // kind
                skuName,                       // sku_name
                skuTier,                       // sku_tier
                skuSize,                       // sku_size
                skuFamily,                     // sku_family
                skuCapacity,                   // sku_capacity
                string(tagsJSON),              // tags
                string(propertiesJSON),        // properties
                rawData,                       // raw_data
                nil,                           // provisioning_state
                nil,                           // power_state
                createdTime,                   // created_time
                changedTime,                   // changed_time
                etag,                          // etag
                apiVersion,                    // api_version
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to store resource %s: %w", resource.Id, err)
        }</span>

        // Store relationships
        <span class="cov0" title="0">for _, rel := range resource.Relationships </span><span class="cov0" title="0">{
                if err := d.StoreRelationship(resource.Id, rel); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to store relationship from %s to %s: %v", resource.Id, rel.TargetId, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// StoreRelationship stores a relationship in the database
func (d *AzureDatabaseIntegration) StoreRelationship(fromID string, relationship *pb.Relationship) error <span class="cov0" title="0">{
        if d.insertRelation == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database not properly initialized")
        }</span>

        // Convert properties to JSON if any
        <span class="cov0" title="0">propertiesJSON := "{}"
        if len(relationship.TargetType) &gt; 0 </span><span class="cov0" title="0">{
                props := map[string]string{
                        "target_type": relationship.TargetType,
                }
                if b, err := json.Marshal(props); err == nil </span><span class="cov0" title="0">{
                        propertiesJSON = string(b)
                }</span>
        }

        <span class="cov0" title="0">_, err := d.insertRelation.Exec(
                fromID,                          // from_id
                relationship.TargetId,           // to_id
                relationship.RelationshipType,   // relationship_type
                "azure",                         // provider
                "",                              // relationship_subtype
                propertiesJSON,                  // properties
                "",                              // from_resource_type (to be filled)
                relationship.TargetType,         // to_resource_type
                "outbound",                      // direction
        )

        return err</span>
}

// StoreResources stores multiple resources in a transaction
func (d *AzureDatabaseIntegration) StoreResources(resources []*pb.Resource) error <span class="cov0" title="0">{
        tx, err := d.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        for _, resource := range resources </span><span class="cov0" title="0">{
                if err := d.StoreResource(resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to store resource in transaction: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit()</span>
}

// QueryResources queries Azure resources from the database
func (d *AzureDatabaseIntegration) QueryResources(query string, args ...interface{}) ([]*pb.Resource, error) <span class="cov0" title="0">{
        rows, err := d.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute query: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var resources []*pb.Resource
        for rows.Next() </span><span class="cov0" title="0">{
                resource := &amp;pb.Resource{}
                var tagsJSON, propertiesJSON string
                var createdTime, changedTime *time.Time
                var skuCapacity *int

                err := rows.Scan(
                        &amp;resource.Id,
                        &amp;resource.Name,
                        &amp;resource.Type,
                        &amp;resource.AccountId,
                        &amp;resource.ParentId,
                        &amp;resource.Region,
                        &amp;resource.Service,
                        &amp;tagsJSON,
                        &amp;propertiesJSON,
                        &amp;resource.RawData,
                        &amp;createdTime,
                        &amp;changedTime,
                        &amp;skuCapacity,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan row: %w", err)
                }</span>

                // Parse tags
                <span class="cov0" title="0">if err := json.Unmarshal([]byte(tagsJSON), &amp;resource.Tags); err != nil </span><span class="cov0" title="0">{
                        resource.Tags = make(map[string]string)
                }</span>

                // Set timestamps
                <span class="cov0" title="0">if createdTime != nil </span><span class="cov0" title="0">{
                        resource.DiscoveredAt = timestamppb.New(*createdTime)
                }</span> else<span class="cov0" title="0"> {
                        resource.DiscoveredAt = timestamppb.Now()
                }</span>

                <span class="cov0" title="0">resource.Provider = "azure"
                resources = append(resources, resource)</span>
        }

        <span class="cov0" title="0">return resources, rows.Err()</span>
}

// GetResourceCount returns the count of Azure resources
func (d *AzureDatabaseIntegration) GetResourceCount() (int, error) <span class="cov0" title="0">{
        var count int
        err := d.db.QueryRow("SELECT COUNT(*) FROM azure_resources").Scan(&amp;count)
        return count, err
}</span>

// GetResourcesByService returns resources for a specific service
func (d *AzureDatabaseIntegration) GetResourcesByService(service string) ([]*pb.Resource, error) <span class="cov0" title="0">{
        query := `
SELECT id, name, type, subscription_id, resource_group, location, service,
       tags, properties, raw_data, created_time, changed_time, sku_capacity
FROM azure_resources 
WHERE service = ?
ORDER BY scanned_at DESC`

        return d.QueryResources(query, service)
}</span>

// Close closes the database connection
func (d *AzureDatabaseIntegration) Close() error <span class="cov0" title="0">{
        if d.insertResource != nil </span><span class="cov0" title="0">{
                d.insertResource.Close()
        }</span>
        <span class="cov0" title="0">if d.insertRelation != nil </span><span class="cov0" title="0">{
                d.insertRelation.Close()
        }</span>
        <span class="cov0" title="0">if d.db != nil </span><span class="cov0" title="0">{
                return d.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetDB returns the underlying database connection
func (d *AzureDatabaseIntegration) GetDB() *sql.DB <span class="cov0" title="0">{
        return d.db
}</span>

// extractResourceGroupFromID extracts resource group name from Azure resource ID
func extractResourceGroupFromID(resourceID string) string <span class="cov0" title="0">{
        // Format: /subscriptions/{sub}/resourceGroups/{rg}/providers/{provider}/{type}/{name}
        parts := strings.Split(resourceID, "/")
        for i, part := range parts </span><span class="cov0" title="0">{
                if strings.EqualFold(part, "resourceGroups") &amp;&amp; i+1 &lt; len(parts) </span><span class="cov0" title="0">{
                        return parts[i+1]
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "strings"
)

// AzureDuckDBSchemas contains all the SQL DDL statements for Azure resources
type AzureDuckDBSchemas struct {
        // Main resources table schema
        AzureResourcesTable string
        
        // Relationships table schema
        AzureRelationshipsTable string
        
        // Scan metadata table schema
        ScanMetadataTable string
        
        // API action metadata table schema
        APIActionMetadataTable string
        
        // Service-specific table generation
        ServiceTables map[string]string
}

// GenerateAzureDuckDBSchemas generates all the DuckDB schemas for Azure resources
func GenerateAzureDuckDBSchemas() *AzureDuckDBSchemas <span class="cov0" title="0">{
        schemas := &amp;AzureDuckDBSchemas{
                ServiceTables: make(map[string]string),
        }
        
        // Main Azure resources table - unified storage for all Azure resources
        schemas.AzureResourcesTable = `
CREATE TABLE IF NOT EXISTS azure_resources (
    -- Primary identifiers
    id VARCHAR PRIMARY KEY,                    -- Azure Resource ID (full path)
    name VARCHAR NOT NULL,                     -- Resource name
    type VARCHAR NOT NULL,                     -- Resource type (e.g., Microsoft.Storage/storageAccounts)
    
    -- Azure-specific identifiers
    resource_id VARCHAR,                       -- Short resource ID
    subscription_id VARCHAR NOT NULL,          -- Azure subscription ID
    resource_group VARCHAR NOT NULL,           -- Resource group name
    
    -- Location and hierarchy
    location VARCHAR NOT NULL,                 -- Azure region (e.g., centralus)
    parent_id VARCHAR,                         -- Parent resource ID for hierarchical resources
    managed_by VARCHAR,                        -- ID of resource managing this resource
    
    -- Service information
    service VARCHAR,                           -- Service name (e.g., storage, compute)
    kind VARCHAR,                              -- Resource kind (e.g., StorageV2)
    
    -- SKU information
    sku_name VARCHAR,                          -- SKU name (e.g., Standard_LRS)
    sku_tier VARCHAR,                          -- SKU tier (e.g., Standard)
    sku_size VARCHAR,                          -- SKU size
    sku_family VARCHAR,                        -- SKU family
    sku_capacity INTEGER,                      -- SKU capacity
    
    -- Metadata
    tags JSON,                                 -- Resource tags
    properties JSON,                           -- Resource-specific properties
    raw_data JSON,                             -- Complete raw resource data
    
    -- State information
    provisioning_state VARCHAR,                -- Current provisioning state
    power_state VARCHAR,                       -- Power state (for VMs)
    
    -- Timestamps
    created_time TIMESTAMP,                    -- Resource creation time
    changed_time TIMESTAMP,                    -- Last modification time
    scanned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- When we discovered this resource
    
    -- Additional metadata
    etag VARCHAR,                              -- Entity tag for optimistic concurrency
    api_version VARCHAR,                       -- API version used to fetch this resource
    
    -- Indexes for performance
    INDEX idx_type (type),
    INDEX idx_service (service),
    INDEX idx_resource_group (resource_group),
    INDEX idx_location (location),
    INDEX idx_subscription_id (subscription_id),
    INDEX idx_parent_id (parent_id),
    INDEX idx_provisioning_state (provisioning_state),
    INDEX idx_scanned_at (scanned_at)
);`

        // Azure relationships table for resource dependencies and associations
        schemas.AzureRelationshipsTable = `
CREATE TABLE IF NOT EXISTS azure_relationships (
    -- Relationship identifiers
    from_id VARCHAR NOT NULL,                  -- Source resource ID
    to_id VARCHAR NOT NULL,                    -- Target resource ID
    relationship_type VARCHAR NOT NULL,        -- Type of relationship
    
    -- Relationship metadata
    relationship_subtype VARCHAR,              -- More specific relationship type
    properties JSON,                           -- Additional relationship properties
    
    -- Azure-specific relationship data
    from_resource_type VARCHAR,                -- Source resource type
    to_resource_type VARCHAR,                  -- Target resource type
    direction VARCHAR DEFAULT 'outbound',      -- Relationship direction
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    discovered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Constraints
    PRIMARY KEY (from_id, to_id, relationship_type),
    
    -- Indexes for graph traversal
    INDEX idx_from_id (from_id),
    INDEX idx_to_id (to_id),
    INDEX idx_relationship_type (relationship_type),
    INDEX idx_from_type (from_resource_type),
    INDEX idx_to_type (to_resource_type)
);`

        // Scan metadata table for tracking scan operations
        schemas.ScanMetadataTable = `
CREATE TABLE IF NOT EXISTS azure_scan_metadata (
    -- Scan identifiers
    id VARCHAR PRIMARY KEY,                    -- Unique scan ID
    scan_type VARCHAR NOT NULL,                -- Type of scan (full, incremental, service)
    
    -- Scan scope
    services LIST&lt;VARCHAR&gt;,                    -- List of services scanned
    resource_groups LIST&lt;VARCHAR&gt;,             -- Resource groups scanned
    locations LIST&lt;VARCHAR&gt;,                   -- Locations scanned
    subscription_id VARCHAR NOT NULL,          -- Subscription scanned
    
    -- Scan results
    total_resources INTEGER DEFAULT 0,         -- Total resources found
    new_resources INTEGER DEFAULT 0,           -- New resources discovered
    updated_resources INTEGER DEFAULT 0,       -- Updated resources
    deleted_resources INTEGER DEFAULT 0,       -- Resources no longer found
    failed_resources INTEGER DEFAULT 0,        -- Resources that failed to scan
    
    -- Performance metrics
    scan_start_time TIMESTAMP NOT NULL,        -- When scan started
    scan_end_time TIMESTAMP,                   -- When scan completed
    duration_ms BIGINT,                        -- Total duration in milliseconds
    
    -- Scan metadata
    initiated_by VARCHAR,                      -- User or system that initiated scan
    scan_reason VARCHAR,                       -- Reason for scan
    error_messages JSON,                       -- Any errors encountered
    warnings JSON,                             -- Any warnings
    metadata JSON,                             -- Additional scan metadata
    
    -- Status
    status VARCHAR DEFAULT 'running',          -- Scan status (running, completed, failed)
    
    -- Indexes
    INDEX idx_scan_type (scan_type),
    INDEX idx_subscription_id (subscription_id),
    INDEX idx_scan_start_time (scan_start_time),
    INDEX idx_status (status)
);`

        // API action metadata for tracking Azure API calls
        schemas.APIActionMetadataTable = `
CREATE TABLE IF NOT EXISTS azure_api_action_metadata (
    -- Action identifiers
    id VARCHAR PRIMARY KEY,                    -- Unique action ID
    correlation_id VARCHAR,                    -- Correlation ID for request tracking
    
    -- API details
    service VARCHAR NOT NULL,                  -- Azure service (e.g., compute, storage)
    resource_provider VARCHAR NOT NULL,        -- Resource provider namespace
    operation_name VARCHAR NOT NULL,           -- API operation name
    operation_type VARCHAR,                    -- Operation type (List, Get, etc.)
    api_version VARCHAR,                       -- API version used
    
    -- Execution details
    execution_time TIMESTAMP NOT NULL,         -- When the API call was made
    location VARCHAR,                          -- Azure region
    subscription_id VARCHAR,                   -- Subscription ID
    
    -- Results
    success BOOLEAN NOT NULL,                  -- Whether the operation succeeded
    status_code INTEGER,                       -- HTTP status code
    duration_ms BIGINT,                        -- Duration in milliseconds
    resource_count INTEGER DEFAULT 0,          -- Number of resources returned
    
    -- Request details
    request_method VARCHAR,                    -- HTTP method (GET, POST, etc.)
    request_path VARCHAR,                      -- API path
    request_headers JSON,                      -- Request headers (sanitized)
    request_body_size INTEGER,                 -- Size of request body
    
    -- Response details
    response_headers JSON,                     -- Response headers (sanitized)
    response_body_size INTEGER,                -- Size of response body
    
    -- Error information
    error_code VARCHAR,                        -- Azure error code
    error_message VARCHAR,                     -- Error message
    error_details JSON,                        -- Detailed error information
    
    -- Rate limiting
    rate_limit_remaining INTEGER,              -- Remaining API calls
    rate_limit_reset_time TIMESTAMP,           -- When rate limit resets
    
    -- Additional metadata
    client_request_id VARCHAR,                 -- Client request ID
    request_charge DOUBLE,                     -- Request units consumed (for Cosmos DB)
    metadata JSON,                             -- Additional metadata
    
    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Indexes
    INDEX idx_service (service),
    INDEX idx_operation_name (operation_name),
    INDEX idx_execution_time (execution_time),
    INDEX idx_success (success),
    INDEX idx_subscription_id (subscription_id),
    INDEX idx_correlation_id (correlation_id)
);`

        // Generate service-specific tables for common Azure services
        schemas.generateServiceSpecificTables()
        
        return schemas
}</span>

// generateServiceSpecificTables creates service-specific table schemas
func (s *AzureDuckDBSchemas) generateServiceSpecificTables() <span class="cov0" title="0">{
        // Storage Accounts table
        s.ServiceTables["storage_accounts"] = `
CREATE TABLE IF NOT EXISTS azure_storage_accounts (
    -- Identifiers
    id VARCHAR PRIMARY KEY,
    name VARCHAR NOT NULL UNIQUE,
    resource_group VARCHAR NOT NULL,
    location VARCHAR NOT NULL,
    
    -- Storage configuration
    account_kind VARCHAR,                      -- StorageV2, BlobStorage, etc.
    account_tier VARCHAR,                      -- Standard, Premium
    replication_type VARCHAR,                  -- LRS, GRS, ZRS, etc.
    access_tier VARCHAR,                       -- Hot, Cool, Archive
    
    -- Encryption settings
    encryption_key_source VARCHAR,             -- Microsoft.Storage, Microsoft.Keyvault
    encryption_enabled BOOLEAN DEFAULT true,
    
    -- Network settings
    https_traffic_only BOOLEAN DEFAULT true,
    minimum_tls_version VARCHAR,
    public_network_access VARCHAR,
    
    -- Endpoints
    primary_blob_endpoint VARCHAR,
    primary_file_endpoint VARCHAR,
    primary_queue_endpoint VARCHAR,
    primary_table_endpoint VARCHAR,
    
    -- Features
    blob_public_access BOOLEAN,
    hierarchical_namespace BOOLEAN,            -- Data Lake Gen2
    nfs_v3_enabled BOOLEAN,
    large_file_shares_enabled BOOLEAN,
    
    -- Metadata
    tags JSON,
    properties JSON,
    created_time TIMESTAMP,
    last_modified TIMESTAMP,
    
    -- Indexes
    INDEX idx_account_kind (account_kind),
    INDEX idx_replication_type (replication_type),
    INDEX idx_access_tier (access_tier)
);`

        // Virtual Machines table
        s.ServiceTables["virtual_machines"] = `
CREATE TABLE IF NOT EXISTS azure_virtual_machines (
    -- Identifiers
    id VARCHAR PRIMARY KEY,
    name VARCHAR NOT NULL,
    resource_group VARCHAR NOT NULL,
    location VARCHAR NOT NULL,
    
    -- VM configuration
    vm_size VARCHAR NOT NULL,                  -- Standard_D2s_v3, etc.
    os_type VARCHAR,                           -- Linux, Windows
    os_publisher VARCHAR,
    os_offer VARCHAR,
    os_sku VARCHAR,
    os_version VARCHAR,
    
    -- Hardware
    cpu_cores INTEGER,
    memory_gb DOUBLE,
    
    -- Storage
    os_disk_id VARCHAR,
    os_disk_type VARCHAR,                      -- Premium_LRS, Standard_LRS
    os_disk_size_gb INTEGER,
    data_disk_count INTEGER DEFAULT 0,
    
    -- Network
    primary_nic_id VARCHAR,
    network_interface_ids JSON,                -- Array of NIC IDs
    private_ip_address VARCHAR,
    public_ip_address VARCHAR,
    
    -- Availability
    availability_set_id VARCHAR,
    availability_zone VARCHAR,
    proximity_placement_group_id VARCHAR,
    
    -- State
    power_state VARCHAR,                       -- running, stopped, deallocated
    provisioning_state VARCHAR,
    
    -- Security
    security_profile JSON,
    boot_diagnostics_enabled BOOLEAN,
    
    -- Metadata
    tags JSON,
    properties JSON,
    created_time TIMESTAMP,
    last_modified TIMESTAMP,
    
    -- Indexes
    INDEX idx_vm_size (vm_size),
    INDEX idx_os_type (os_type),
    INDEX idx_power_state (power_state),
    INDEX idx_availability_set_id (availability_set_id)
);`

        // Virtual Networks table
        s.ServiceTables["virtual_networks"] = `
CREATE TABLE IF NOT EXISTS azure_virtual_networks (
    -- Identifiers
    id VARCHAR PRIMARY KEY,
    name VARCHAR NOT NULL,
    resource_group VARCHAR NOT NULL,
    location VARCHAR NOT NULL,
    
    -- Network configuration
    address_space JSON,                        -- Array of address prefixes
    dns_servers JSON,                          -- Custom DNS servers
    
    -- Subnets
    subnet_count INTEGER DEFAULT 0,
    subnets JSON,                              -- Array of subnet configurations
    
    -- Peering
    peering_count INTEGER DEFAULT 0,
    peerings JSON,                             -- Array of peering configurations
    
    -- DDoS protection
    ddos_protection_enabled BOOLEAN DEFAULT false,
    ddos_protection_plan_id VARCHAR,
    
    -- Service endpoints
    service_endpoints JSON,
    
    -- Metadata
    tags JSON,
    properties JSON,
    created_time TIMESTAMP,
    last_modified TIMESTAMP,
    
    -- Indexes
    INDEX idx_subnet_count (subnet_count),
    INDEX idx_peering_count (peering_count)
);`

        // Key Vaults table
        s.ServiceTables["key_vaults"] = `
CREATE TABLE IF NOT EXISTS azure_key_vaults (
    -- Identifiers
    id VARCHAR PRIMARY KEY,
    name VARCHAR NOT NULL UNIQUE,
    resource_group VARCHAR NOT NULL,
    location VARCHAR NOT NULL,
    
    -- Vault configuration
    vault_uri VARCHAR NOT NULL,
    tenant_id VARCHAR NOT NULL,
    sku_name VARCHAR,                          -- standard, premium
    sku_family VARCHAR DEFAULT 'A',
    
    -- Access policies
    access_policy_count INTEGER DEFAULT 0,
    access_policies JSON,                      -- Array of access policies
    enable_rbac_authorization BOOLEAN DEFAULT false,
    
    -- Features
    enabled_for_deployment BOOLEAN DEFAULT false,
    enabled_for_disk_encryption BOOLEAN DEFAULT false,
    enabled_for_template_deployment BOOLEAN DEFAULT false,
    
    -- Soft delete settings
    soft_delete_enabled BOOLEAN DEFAULT true,
    soft_delete_retention_days INTEGER DEFAULT 90,
    purge_protection_enabled BOOLEAN DEFAULT false,
    
    -- Network settings
    public_network_access VARCHAR,
    network_acls JSON,
    
    -- Metadata
    tags JSON,
    properties JSON,
    created_time TIMESTAMP,
    last_modified TIMESTAMP,
    
    -- Indexes
    INDEX idx_tenant_id (tenant_id),
    INDEX idx_sku_name (sku_name),
    INDEX idx_vault_uri (vault_uri)
);`
}</span>

// GetCreateTableSQL returns the CREATE TABLE SQL for a specific table
func (s *AzureDuckDBSchemas) GetCreateTableSQL(tableName string) string <span class="cov0" title="0">{
        switch tableName </span>{
        case "azure_resources":<span class="cov0" title="0">
                return s.AzureResourcesTable</span>
        case "azure_relationships":<span class="cov0" title="0">
                return s.AzureRelationshipsTable</span>
        case "azure_scan_metadata":<span class="cov0" title="0">
                return s.ScanMetadataTable</span>
        case "azure_api_action_metadata":<span class="cov0" title="0">
                return s.APIActionMetadataTable</span>
        default:<span class="cov0" title="0">
                // Check service-specific tables
                if sql, exists := s.ServiceTables[tableName]; exists </span><span class="cov0" title="0">{
                        return sql
                }</span>
                <span class="cov0" title="0">return ""</span>
        }
}

// GetAllCreateTableSQL returns all CREATE TABLE statements
func (s *AzureDuckDBSchemas) GetAllCreateTableSQL() []string <span class="cov0" title="0">{
        sqls := []string{
                s.AzureResourcesTable,
                s.AzureRelationshipsTable,
                s.ScanMetadataTable,
                s.APIActionMetadataTable,
        }
        
        // Add service-specific tables
        for _, sql := range s.ServiceTables </span><span class="cov0" title="0">{
                sqls = append(sqls, sql)
        }</span>
        
        <span class="cov0" title="0">return sqls</span>
}

// GenerateResourceInsertSQL generates an INSERT statement for azure_resources table
func GenerateResourceInsertSQL(resource map[string]interface{}) (string, []interface{}) <span class="cov0" title="0">{
        columns := []string{
                "id", "name", "type", "resource_id", "subscription_id", "resource_group",
                "location", "parent_id", "managed_by", "service", "kind",
                "sku_name", "sku_tier", "sku_size", "sku_family", "sku_capacity",
                "tags", "properties", "raw_data", "provisioning_state", "power_state",
                "created_time", "changed_time", "etag", "api_version",
        }
        
        placeholders := make([]string, len(columns))
        values := make([]interface{}, len(columns))
        
        for i := range columns </span><span class="cov0" title="0">{
                placeholders[i] = "?"
                if val, exists := resource[columns[i]]; exists </span><span class="cov0" title="0">{
                        values[i] = val
                }</span> else<span class="cov0" title="0"> {
                        values[i] = nil
                }</span>
        }
        
        <span class="cov0" title="0">sql := fmt.Sprintf(
                "INSERT INTO azure_resources (%s) VALUES (%s)",
                strings.Join(columns, ", "),
                strings.Join(placeholders, ", "),
        )
        
        return sql, values</span>
}

// GenerateRelationshipInsertSQL generates an INSERT statement for azure_relationships table
func GenerateRelationshipInsertSQL(fromID, toID, relationType string, properties map[string]interface{}) (string, []interface{}) <span class="cov0" title="0">{
        sql := `INSERT INTO azure_relationships 
                (from_id, to_id, relationship_type, relationship_subtype, properties, 
                 from_resource_type, to_resource_type, direction) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)`
        
        values := []interface{}{
                fromID,
                toID,
                relationType,
                properties["subtype"],
                properties,
                properties["from_type"],
                properties["to_type"],
                properties["direction"],
        }
        
        return sql, values
}</span>

// GenerateScanMetadataInsertSQL generates an INSERT statement for scan metadata
func GenerateScanMetadataInsertSQL(scanID string, scanData map[string]interface{}) (string, []interface{}) <span class="cov0" title="0">{
        sql := `INSERT INTO azure_scan_metadata 
                (id, scan_type, services, resource_groups, locations, subscription_id,
                 total_resources, new_resources, updated_resources, deleted_resources, failed_resources,
                 scan_start_time, scan_end_time, duration_ms, initiated_by, scan_reason,
                 error_messages, warnings, metadata, status) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
        
        values := []interface{}{
                scanID,
                scanData["scan_type"],
                scanData["services"],
                scanData["resource_groups"],
                scanData["locations"],
                scanData["subscription_id"],
                scanData["total_resources"],
                scanData["new_resources"],
                scanData["updated_resources"],
                scanData["deleted_resources"],
                scanData["failed_resources"],
                scanData["scan_start_time"],
                scanData["scan_end_time"],
                scanData["duration_ms"],
                scanData["initiated_by"],
                scanData["scan_reason"],
                scanData["error_messages"],
                scanData["warnings"],
                scanData["metadata"],
                scanData["status"],
        }
        
        return sql, values
}</span>

// ExtractRelationshipsFromResource extracts relationships from an Azure resource
func ExtractRelationshipsFromResource(resource map[string]interface{}) []map[string]interface{} <span class="cov0" title="0">{
        relationships := []map[string]interface{}{}
        
        resourceID := resource["id"].(string)
        resourceType := resource["type"].(string)
        
        // Extract parent relationship
        if parentID, exists := resource["parent_id"]; exists &amp;&amp; parentID != nil &amp;&amp; parentID != "" </span><span class="cov0" title="0">{
                relationships = append(relationships, map[string]interface{}{
                        "from_id":           resourceID,
                        "to_id":             parentID.(string),
                        "relationship_type": "child_of",
                        "properties": map[string]interface{}{
                                "subtype":   "parent_child",
                                "from_type": resourceType,
                                "to_type":   extractResourceType(parentID.(string)),
                                "direction": "outbound",
                        },
                })
        }</span>
        
        // Extract managed_by relationship
        <span class="cov0" title="0">if managedBy, exists := resource["managed_by"]; exists &amp;&amp; managedBy != nil &amp;&amp; managedBy != "" </span><span class="cov0" title="0">{
                relationships = append(relationships, map[string]interface{}{
                        "from_id":           resourceID,
                        "to_id":             managedBy.(string),
                        "relationship_type": "managed_by",
                        "properties": map[string]interface{}{
                                "subtype":   "management",
                                "from_type": resourceType,
                                "to_type":   extractResourceType(managedBy.(string)),
                                "direction": "outbound",
                        },
                })
        }</span>
        
        // Extract resource-specific relationships
        <span class="cov0" title="0">if properties, exists := resource["properties"].(map[string]interface{}); exists </span><span class="cov0" title="0">{
                // Virtual Machine relationships
                if strings.Contains(resourceType, "Microsoft.Compute/virtualMachines") </span><span class="cov0" title="0">{
                        // Network interfaces
                        if nics, exists := properties["networkProfile"].(map[string]interface{}); exists </span><span class="cov0" title="0">{
                                if interfaces, exists := nics["networkInterfaces"].([]interface{}); exists </span><span class="cov0" title="0">{
                                        for _, nic := range interfaces </span><span class="cov0" title="0">{
                                                if nicMap, ok := nic.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                        if nicID, exists := nicMap["id"].(string); exists </span><span class="cov0" title="0">{
                                                                relationships = append(relationships, map[string]interface{}{
                                                                        "from_id":           resourceID,
                                                                        "to_id":             nicID,
                                                                        "relationship_type": "uses",
                                                                        "properties": map[string]interface{}{
                                                                                "subtype":   "network_interface",
                                                                                "from_type": resourceType,
                                                                                "to_type":   "Microsoft.Network/networkInterfaces",
                                                                                "direction": "outbound",
                                                                        },
                                                                })
                                                        }</span>
                                                }
                                        }
                                }
                        }
                        
                        // Availability Set
                        <span class="cov0" title="0">if availSet, exists := properties["availabilitySet"].(map[string]interface{}); exists </span><span class="cov0" title="0">{
                                if availSetID, exists := availSet["id"].(string); exists </span><span class="cov0" title="0">{
                                        relationships = append(relationships, map[string]interface{}{
                                                "from_id":           resourceID,
                                                "to_id":             availSetID,
                                                "relationship_type": "member_of",
                                                "properties": map[string]interface{}{
                                                        "subtype":   "availability_set",
                                                        "from_type": resourceType,
                                                        "to_type":   "Microsoft.Compute/availabilitySets",
                                                        "direction": "outbound",
                                                },
                                        })
                                }</span>
                        }
                }
                
                // Storage Account relationships
                <span class="cov0" title="0">if strings.Contains(resourceType, "Microsoft.Storage/storageAccounts") </span><span class="cov0" title="0">{
                        // Private endpoints
                        if privateEndpoints, exists := properties["privateEndpointConnections"].([]interface{}); exists </span><span class="cov0" title="0">{
                                for _, pe := range privateEndpoints </span><span class="cov0" title="0">{
                                        if peMap, ok := pe.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if peProps, exists := peMap["properties"].(map[string]interface{}); exists </span><span class="cov0" title="0">{
                                                        if privateEndpoint, exists := peProps["privateEndpoint"].(map[string]interface{}); exists </span><span class="cov0" title="0">{
                                                                if peID, exists := privateEndpoint["id"].(string); exists </span><span class="cov0" title="0">{
                                                                        relationships = append(relationships, map[string]interface{}{
                                                                                "from_id":           resourceID,
                                                                                "to_id":             peID,
                                                                                "relationship_type": "connected_to",
                                                                                "properties": map[string]interface{}{
                                                                                        "subtype":   "private_endpoint",
                                                                                        "from_type": resourceType,
                                                                                        "to_type":   "Microsoft.Network/privateEndpoints",
                                                                                        "direction": "outbound",
                                                                                },
                                                                        })
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }
                
                // Virtual Network relationships
                <span class="cov0" title="0">if strings.Contains(resourceType, "Microsoft.Network/virtualNetworks") </span><span class="cov0" title="0">{
                        // Peerings
                        if peerings, exists := properties["virtualNetworkPeerings"].([]interface{}); exists </span><span class="cov0" title="0">{
                                for _, peering := range peerings </span><span class="cov0" title="0">{
                                        if peerMap, ok := peering.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if peerProps, exists := peerMap["properties"].(map[string]interface{}); exists </span><span class="cov0" title="0">{
                                                        if remoteVnet, exists := peerProps["remoteVirtualNetwork"].(map[string]interface{}); exists </span><span class="cov0" title="0">{
                                                                if vnetID, exists := remoteVnet["id"].(string); exists </span><span class="cov0" title="0">{
                                                                        relationships = append(relationships, map[string]interface{}{
                                                                                "from_id":           resourceID,
                                                                                "to_id":             vnetID,
                                                                                "relationship_type": "peered_with",
                                                                                "properties": map[string]interface{}{
                                                                                        "subtype":   "vnet_peering",
                                                                                        "from_type": resourceType,
                                                                                        "to_type":   "Microsoft.Network/virtualNetworks",
                                                                                        "direction": "bidirectional",
                                                                                },
                                                                        })
                                                                }</span>
                                                        }
                                                }
                                        }
                                }
                        }
                }
        }
        
        <span class="cov0" title="0">return relationships</span>
}

// extractResourceType extracts the resource type from an Azure resource ID
func extractResourceType(resourceID string) string <span class="cov0" title="0">{
        parts := strings.Split(resourceID, "/")
        if len(parts) &gt;= 8 </span><span class="cov0" title="0">{
                // Format: /subscriptions/{sub}/resourceGroups/{rg}/providers/{provider}/{type}/{name}
                return fmt.Sprintf("%s/%s", parts[6], parts[7])
        }</span>
        <span class="cov0" title="0">return "Unknown"</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"
        "strings"
        "sync"

        "github.com/Azure/azure-sdk-for-go/sdk/azcore"
        "github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/resources/armresources"
)

// AzureServiceDiscovery handles dynamic discovery of Azure services
type AzureServiceDiscovery struct {
        credential      azcore.TokenCredential
        subscriptionID  string
        providersClient *armresources.ProvidersClient
        cache           map[string]*ProviderInfo
        mu              sync.RWMutex
}

// ProviderInfo contains information about an Azure resource provider
type ProviderInfo struct {
        Namespace         string
        ResourceTypes     []ResourceTypeInfo
        RegistrationState string
        Locations         []string
}

// ResourceTypeInfo contains information about a specific resource type
type ResourceTypeInfo struct {
        ResourceType string
        Locations    []string
        APIVersions  []string
        Capabilities []string
        Properties   map[string]interface{}
}

// NewAzureServiceDiscovery creates a new Azure service discovery instance
func NewAzureServiceDiscovery(cred azcore.TokenCredential, subID string) *AzureServiceDiscovery <span class="cov0" title="0">{
        client, _ := armresources.NewProvidersClient(subID, cred, nil)
        return &amp;AzureServiceDiscovery{
                credential:      cred,
                subscriptionID:  subID,
                providersClient: client,
                cache:           make(map[string]*ProviderInfo),
        }
}</span>

// DiscoverProviders discovers all Azure resource providers and their capabilities
func (d *AzureServiceDiscovery) DiscoverProviders(ctx context.Context) ([]*ProviderInfo, error) <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()

        var providers []*ProviderInfo

        // List all resource providers with detailed information
        pager := d.providersClient.NewListPager(&amp;armresources.ProvidersClientListOptions{
                Expand: to.Ptr("resourceTypes/aliases"), // Get detailed info including aliases
        })

        for pager.More() </span><span class="cov0" title="0">{
                page, err := pager.NextPage(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to list providers: %w", err)
                }</span>

                <span class="cov0" title="0">for _, provider := range page.Value </span><span class="cov0" title="0">{
                        if provider.Namespace == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">providerInfo := &amp;ProviderInfo{
                                Namespace:     *provider.Namespace,
                                ResourceTypes: []ResourceTypeInfo{},
                        }

                        // Set registration state
                        if provider.RegistrationState != nil </span><span class="cov0" title="0">{
                                providerInfo.RegistrationState = *provider.RegistrationState
                        }</span>

                        // Extract resource types
                        <span class="cov0" title="0">if provider.ResourceTypes != nil </span><span class="cov0" title="0">{
                                for _, rt := range provider.ResourceTypes </span><span class="cov0" title="0">{
                                        if rt.ResourceType == nil </span><span class="cov0" title="0">{
                                                continue</span>
                                        }

                                        <span class="cov0" title="0">resourceType := ResourceTypeInfo{
                                                ResourceType: *rt.ResourceType,
                                                Properties:   make(map[string]interface{}),
                                        }

                                        // Get locations
                                        if rt.Locations != nil </span><span class="cov0" title="0">{
                                                resourceType.Locations = make([]string, 0, len(rt.Locations))
                                                for _, loc := range rt.Locations </span><span class="cov0" title="0">{
                                                        if loc != nil </span><span class="cov0" title="0">{
                                                                resourceType.Locations = append(resourceType.Locations, *loc)
                                                        }</span>
                                                }
                                        }

                                        // Get API versions
                                        <span class="cov0" title="0">if rt.APIVersions != nil </span><span class="cov0" title="0">{
                                                resourceType.APIVersions = make([]string, 0, len(rt.APIVersions))
                                                for _, ver := range rt.APIVersions </span><span class="cov0" title="0">{
                                                        if ver != nil </span><span class="cov0" title="0">{
                                                                resourceType.APIVersions = append(resourceType.APIVersions, *ver)
                                                        }</span>
                                                }
                                        }

                                        // Get capabilities
                                        <span class="cov0" title="0">if rt.Capabilities != nil </span><span class="cov0" title="0">{
                                                resourceType.Capabilities = []string{*rt.Capabilities}
                                        }</span>

                                        // Extract additional properties
                                        <span class="cov0" title="0">if rt.Properties != nil </span><span class="cov0" title="0">{
                                                // Store any additional properties that might be useful
                                                resourceType.Properties["properties"] = rt.Properties
                                        }</span>

                                        // Check if resource type supports common operations
                                        <span class="cov0" title="0">resourceType.Properties["supports_list"] = d.supportsListOperation(providerInfo.Namespace, resourceType.ResourceType)
                                        resourceType.Properties["supports_get"] = d.supportsGetOperation(providerInfo.Namespace, resourceType.ResourceType)
                                        resourceType.Properties["supports_tags"] = d.supportsTags(providerInfo.Namespace, resourceType.ResourceType)

                                        providerInfo.ResourceTypes = append(providerInfo.ResourceTypes, resourceType)</span>
                                }
                        }

                        // Only include registered providers or those we specifically want
                        <span class="cov0" title="0">if d.shouldIncludeProvider(providerInfo) </span><span class="cov0" title="0">{
                                providers = append(providers, providerInfo)
                                d.cache[providerInfo.Namespace] = providerInfo
                        }</span>
                }
        }

        <span class="cov0" title="0">return providers, nil</span>
}

// GetProvider returns cached provider information
func (d *AzureServiceDiscovery) GetProvider(namespace string) *ProviderInfo <span class="cov0" title="0">{
        d.mu.RLock()
        defer d.mu.RUnlock()
        return d.cache[namespace]
}</span>

// GetProviderByService returns provider information by service name (e.g., "compute" -&gt; "Microsoft.Compute")
func (d *AzureServiceDiscovery) GetProviderByService(serviceName string) *ProviderInfo <span class="cov0" title="0">{
        namespace := fmt.Sprintf("Microsoft.%s", strings.Title(serviceName))
        return d.GetProvider(namespace)
}</span>

// ListRegisteredProviders returns only registered providers
func (d *AzureServiceDiscovery) ListRegisteredProviders(ctx context.Context) ([]*ProviderInfo, error) <span class="cov0" title="0">{
        allProviders, err := d.DiscoverProviders(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var registered []*ProviderInfo
        for _, provider := range allProviders </span><span class="cov0" title="0">{
                if provider.RegistrationState == "Registered" </span><span class="cov0" title="0">{
                        registered = append(registered, provider)
                }</span>
        }

        <span class="cov0" title="0">return registered, nil</span>
}

// GetResourceTypesForProvider returns all resource types for a specific provider
func (d *AzureServiceDiscovery) GetResourceTypesForProvider(ctx context.Context, namespace string) ([]ResourceTypeInfo, error) <span class="cov0" title="0">{
        provider := d.GetProvider(namespace)
        if provider != nil </span><span class="cov0" title="0">{
                return provider.ResourceTypes, nil
        }</span>

        // If not cached, fetch specifically for this provider
        <span class="cov0" title="0">providerClient := d.providersClient
        result, err := providerClient.Get(ctx, namespace, &amp;armresources.ProvidersClientGetOptions{
                Expand: to.Ptr("resourceTypes"),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get provider %s: %w", namespace, err)
        }</span>

        <span class="cov0" title="0">var resourceTypes []ResourceTypeInfo
        if result.ResourceTypes != nil </span><span class="cov0" title="0">{
                for _, rt := range result.ResourceTypes </span><span class="cov0" title="0">{
                        if rt.ResourceType == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">resourceType := ResourceTypeInfo{
                                ResourceType: *rt.ResourceType,
                                Properties:   make(map[string]interface{}),
                        }

                        // Extract details as in DiscoverProviders
                        if rt.Locations != nil </span><span class="cov0" title="0">{
                                resourceType.Locations = make([]string, 0, len(rt.Locations))
                                for _, loc := range rt.Locations </span><span class="cov0" title="0">{
                                        if loc != nil </span><span class="cov0" title="0">{
                                                resourceType.Locations = append(resourceType.Locations, *loc)
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">if rt.APIVersions != nil </span><span class="cov0" title="0">{
                                resourceType.APIVersions = make([]string, 0, len(rt.APIVersions))
                                for _, ver := range rt.APIVersions </span><span class="cov0" title="0">{
                                        if ver != nil </span><span class="cov0" title="0">{
                                                resourceType.APIVersions = append(resourceType.APIVersions, *ver)
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">resourceTypes = append(resourceTypes, resourceType)</span>
                }
        }

        <span class="cov0" title="0">return resourceTypes, nil</span>
}

// shouldIncludeProvider determines if a provider should be included in discovery
func (d *AzureServiceDiscovery) shouldIncludeProvider(provider *ProviderInfo) bool <span class="cov0" title="0">{
        // Include registered providers
        if provider.RegistrationState == "Registered" </span><span class="cov0" title="0">{
                return true
        }</span>

        // Include important Microsoft providers even if not registered
        <span class="cov0" title="0">importantProviders := []string{
                "Microsoft.Compute",
                "Microsoft.Storage",
                "Microsoft.Network",
                "Microsoft.KeyVault",
                "Microsoft.Sql",
                "Microsoft.Web",
                "Microsoft.ContainerService",
                "Microsoft.ContainerRegistry",
                "Microsoft.DocumentDB",
                "Microsoft.Insights",
                "Microsoft.Authorization",
                "Microsoft.Resources",
        }

        for _, important := range importantProviders </span><span class="cov0" title="0">{
                if provider.Namespace == important </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Exclude providers with no resource types
        <span class="cov0" title="0">return len(provider.ResourceTypes) &gt; 0</span>
}

// supportsListOperation checks if a resource type supports list operations
func (d *AzureServiceDiscovery) supportsListOperation(namespace, resourceType string) bool <span class="cov0" title="0">{
        // Most Azure resource types support list operations
        // This could be enhanced with more specific logic
        excludedTypes := []string{
                "operations",
                "locations",
                "checkNameAvailability",
        }

        lowerType := strings.ToLower(resourceType)
        for _, excluded := range excludedTypes </span><span class="cov0" title="0">{
                if strings.Contains(lowerType, excluded) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// supportsGetOperation checks if a resource type supports get operations
func (d *AzureServiceDiscovery) supportsGetOperation(namespace, resourceType string) bool <span class="cov0" title="0">{
        // Most Azure resource types support get operations
        return d.supportsListOperation(namespace, resourceType)
}</span>

// supportsTags checks if a resource type supports tags
func (d *AzureServiceDiscovery) supportsTags(namespace, resourceType string) bool <span class="cov0" title="0">{
        // Most Azure resources support tags, with some exceptions
        nonTaggableTypes := []string{
                "operations",
                "locations",
                "checkNameAvailability",
                "usages",
                "quotas",
                "metrics",
                "diagnosticSettings",
        }

        lowerType := strings.ToLower(resourceType)
        for _, nonTaggable := range nonTaggableTypes </span><span class="cov0" title="0">{
                if strings.Contains(lowerType, nonTaggable) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// GetLatestAPIVersion returns the latest API version for a resource type
func (d *AzureServiceDiscovery) GetLatestAPIVersion(namespace, resourceType string) string <span class="cov0" title="0">{
        provider := d.GetProvider(namespace)
        if provider == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">for _, rt := range provider.ResourceTypes </span><span class="cov0" title="0">{
                if rt.ResourceType == resourceType &amp;&amp; len(rt.APIVersions) &gt; 0 </span><span class="cov0" title="0">{
                        // API versions are typically sorted with latest first
                        return rt.APIVersions[0]
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// GetSupportedLocations returns supported locations for a resource type
func (d *AzureServiceDiscovery) GetSupportedLocations(namespace, resourceType string) []string <span class="cov0" title="0">{
        provider := d.GetProvider(namespace)
        if provider == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, rt := range provider.ResourceTypes </span><span class="cov0" title="0">{
                if rt.ResourceType == resourceType </span><span class="cov0" title="0">{
                        return rt.Locations
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetProviderCapabilities returns capabilities for a provider
func (d *AzureServiceDiscovery) GetProviderCapabilities(namespace string) map[string]interface{} <span class="cov0" title="0">{
        provider := d.GetProvider(namespace)
        if provider == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">capabilities := make(map[string]interface{})
        capabilities["namespace"] = provider.Namespace
        capabilities["registration_state"] = provider.RegistrationState
        capabilities["resource_type_count"] = len(provider.ResourceTypes)

        // Aggregate capabilities across resource types
        var allLocations []string
        var allAPIVersions []string
        locationSet := make(map[string]bool)
        versionSet := make(map[string]bool)

        for _, rt := range provider.ResourceTypes </span><span class="cov0" title="0">{
                for _, loc := range rt.Locations </span><span class="cov0" title="0">{
                        if !locationSet[loc] </span><span class="cov0" title="0">{
                                allLocations = append(allLocations, loc)
                                locationSet[loc] = true
                        }</span>
                }
                <span class="cov0" title="0">for _, ver := range rt.APIVersions </span><span class="cov0" title="0">{
                        if !versionSet[ver] </span><span class="cov0" title="0">{
                                allAPIVersions = append(allAPIVersions, ver)
                                versionSet[ver] = true
                        }</span>
                }
        }

        <span class="cov0" title="0">capabilities["supported_locations"] = allLocations
        capabilities["api_versions"] = allAPIVersions

        return capabilities</span>
}

// RefreshProvider refreshes information for a specific provider
func (d *AzureServiceDiscovery) RefreshProvider(ctx context.Context, namespace string) error <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()

        result, err := d.providersClient.Get(ctx, namespace, &amp;armresources.ProvidersClientGetOptions{
                Expand: to.Ptr("resourceTypes/aliases"),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to refresh provider %s: %w", namespace, err)
        }</span>

        <span class="cov0" title="0">if result.Namespace == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid provider response for %s", namespace)
        }</span>

        <span class="cov0" title="0">providerInfo := &amp;ProviderInfo{
                Namespace:     *result.Namespace,
                ResourceTypes: []ResourceTypeInfo{},
        }

        if result.RegistrationState != nil </span><span class="cov0" title="0">{
                providerInfo.RegistrationState = *result.RegistrationState
        }</span>

        // Process resource types
        <span class="cov0" title="0">if result.ResourceTypes != nil </span><span class="cov0" title="0">{
                for _, rt := range result.ResourceTypes </span><span class="cov0" title="0">{
                        if rt.ResourceType == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">resourceType := ResourceTypeInfo{
                                ResourceType: *rt.ResourceType,
                                Properties:   make(map[string]interface{}),
                        }

                        // Extract details
                        if rt.Locations != nil </span><span class="cov0" title="0">{
                                resourceType.Locations = make([]string, 0, len(rt.Locations))
                                for _, loc := range rt.Locations </span><span class="cov0" title="0">{
                                        if loc != nil </span><span class="cov0" title="0">{
                                                resourceType.Locations = append(resourceType.Locations, *loc)
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">if rt.APIVersions != nil </span><span class="cov0" title="0">{
                                resourceType.APIVersions = make([]string, 0, len(rt.APIVersions))
                                for _, ver := range rt.APIVersions </span><span class="cov0" title="0">{
                                        if ver != nil </span><span class="cov0" title="0">{
                                                resourceType.APIVersions = append(resourceType.APIVersions, *ver)
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">providerInfo.ResourceTypes = append(providerInfo.ResourceTypes, resourceType)</span>
                }
        }

        // Update cache
        <span class="cov0" title="0">d.cache[namespace] = providerInfo

        return nil</span>
}

// GetCommonResourceTypes returns commonly used resource types across providers
func (d *AzureServiceDiscovery) GetCommonResourceTypes() map[string][]string <span class="cov0" title="0">{
        commonTypes := map[string][]string{
                "Microsoft.Compute": {
                        "virtualMachines",
                        "virtualMachineScaleSets",
                        "disks",
                        "snapshots",
                        "images",
                        "availabilitySets",
                },
                "Microsoft.Storage": {
                        "storageAccounts",
                        "storageAccounts/blobServices",
                        "storageAccounts/fileServices",
                        "storageAccounts/queueServices",
                        "storageAccounts/tableServices",
                },
                "Microsoft.Network": {
                        "virtualNetworks",
                        "networkSecurityGroups",
                        "publicIPAddresses",
                        "networkInterfaces",
                        "loadBalancers",
                        "applicationGateways",
                },
                "Microsoft.Web": {
                        "sites",
                        "serverfarms",
                        "certificates",
                },
                "Microsoft.Sql": {
                        "servers",
                        "servers/databases",
                        "servers/elasticPools",
                },
                "Microsoft.KeyVault": {
                        "vaults",
                        "vaults/secrets",
                        "vaults/keys",
                        "vaults/certificates",
                },
        }

        return commonTypes
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "github.com/hashicorp/go-plugin"
        "github.com/jlgore/corkscrew/internal/shared"
)

func main() <span class="cov0" title="0">{
        // Create the Azure provider which implements the CloudProvider interface
        azureProvider := NewAzureProvider()

        // Serve the plugin using the shared plugin configuration
        plugin.Serve(&amp;plugin.ServeConfig{
                HandshakeConfig: shared.HandshakeConfig,
                Plugins: map[string]plugin.Plugin{
                        "provider": &amp;shared.CloudProviderGRPCPlugin{Impl: azureProvider},
                },
                GRPCServer: plugin.DefaultGRPCServer,
        })
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package resourcegraph provides Azure Resource Graph integration for efficient resource discovery
package main

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/Azure/azure-sdk-for-go/sdk/azcore"
        "github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/resourcegraph/armresourcegraph"
        pb "github.com/jlgore/corkscrew/internal/proto"
)

// ResourceGraphClient provides efficient resource querying using Azure Resource Graph
type ResourceGraphClient struct {
        client         *armresourcegraph.Client
        subscriptions  []string
        queryCache     *QueryCache
        queryOptimizer *QueryOptimizer
        mu             sync.RWMutex
}

// NewResourceGraphClient creates a new Resource Graph client
func NewResourceGraphClient(credential azcore.TokenCredential, subscriptions []string) (*ResourceGraphClient, error) <span class="cov0" title="0">{
        client, err := armresourcegraph.NewClient(credential, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create resource graph client: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ResourceGraphClient{
                client:         client,
                subscriptions:  subscriptions,
                queryCache:     NewQueryCache(15 * time.Minute),
                queryOptimizer: NewQueryOptimizer(),
        }, nil</span>
}

// QueryAllResources queries all resources efficiently using Resource Graph
func (c *ResourceGraphClient) QueryAllResources(ctx context.Context) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        query := `
        Resources
        | project id, name, type, location, resourceGroup, subscriptionId, tags, properties
        | order by type asc, name asc
        `

        return c.executeQuery(ctx, query)
}</span>

// QueryResourcesByType queries resources of specific types
func (c *ResourceGraphClient) QueryResourcesByType(ctx context.Context, resourceTypes []string) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        // Build optimized query
        typeFilter := c.buildTypeFilter(resourceTypes)

        query := fmt.Sprintf(`
        Resources
        | where %s
        | project id, name, type, location, resourceGroup, subscriptionId, tags, properties
        | order by type asc, name asc
        `, typeFilter)

        return c.executeQuery(ctx, query)
}</span>

// QueryResourcesWithFilter queries resources with complex filters
func (c *ResourceGraphClient) QueryResourcesWithFilter(ctx context.Context, filters map[string]interface{}) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        // Build KQL query from filters
        query := c.queryOptimizer.BuildQuery(filters)

        // Check cache first
        cacheKey := c.generateCacheKey(query, c.subscriptions)
        if cached, found := c.queryCache.Get(cacheKey); found </span><span class="cov0" title="0">{
                return cached, nil
        }</span>

        // Execute query
        <span class="cov0" title="0">resources, err := c.executeQuery(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Cache results
        <span class="cov0" title="0">c.queryCache.Set(cacheKey, resources)
        
        return resources, nil</span>
}

// QueryResourceChanges queries for resource changes since a specific time
func (c *ResourceGraphClient) QueryResourceChanges(ctx context.Context, since time.Time) ([]*ResourceChange, error) <span class="cov0" title="0">{
        query := fmt.Sprintf(`
        resourcechanges
        | where timestamp &gt; datetime(%s)
        | project timestamp, changeType, targetResourceId, targetResourceType, changes
        | order by timestamp desc
        `, since.Format(time.RFC3339))

        // Convert []string to []*string
        subscriptions := make([]*string, len(c.subscriptions))
        for i, sub := range c.subscriptions </span><span class="cov0" title="0">{
                subscriptions[i] = to.Ptr(sub)
        }</span>

        <span class="cov0" title="0">request := armresourcegraph.QueryRequest{
                Query:         to.Ptr(query),
                Subscriptions: subscriptions,
                Options: &amp;armresourcegraph.QueryRequestOptions{
                        ResultFormat: to.Ptr(armresourcegraph.ResultFormatObjectArray),
                },
        }

        result, err := c.client.Resources(ctx, request, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query resource changes: %w", err)
        }</span>

        <span class="cov0" title="0">return c.parseChangeResults(&amp;result.QueryResponse)</span>
}

// QueryResourceRelationships discovers relationships between resources
func (c *ResourceGraphClient) QueryResourceRelationships(ctx context.Context, resourceID string) ([]*ResourceRelationship, error) <span class="cov0" title="0">{
        // Query for resources that reference the given resource ID
        query := fmt.Sprintf(`
        Resources
        | where properties contains '%s' or dependsOn contains '%s'
        | project id, name, type, properties
        | limit 100
        `, resourceID, resourceID)

        resources, err := c.executeQuery(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Analyze properties to find relationships
        <span class="cov0" title="0">relationships := c.analyzeRelationships(resourceID, resources)

        return relationships, nil</span>
}

// QueryResourcesByTags queries resources with specific tags
func (c *ResourceGraphClient) QueryResourcesByTags(ctx context.Context, tags map[string]string) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        tagFilters := []string{}
        for key, value := range tags </span><span class="cov0" title="0">{
                if value == "" </span><span class="cov0" title="0">{
                        tagFilters = append(tagFilters, fmt.Sprintf("tags contains '%s'", key))
                }</span> else<span class="cov0" title="0"> {
                        tagFilters = append(tagFilters, fmt.Sprintf("tags['%s'] == '%s'", key, value))
                }</span>
        }

        <span class="cov0" title="0">query := fmt.Sprintf(`
        Resources
        | where %s
        | project id, name, type, location, resourceGroup, subscriptionId, tags, properties
        | order by type asc, name asc
        `, strings.Join(tagFilters, " and "))

        return c.executeQuery(ctx, query)</span>
}

// QueryResourceCosts queries cost information for resources (if available)
func (c *ResourceGraphClient) QueryResourceCosts(ctx context.Context, resourceGroup string) ([]*ResourceCost, error) <span class="cov0" title="0">{
        // This would integrate with Azure Cost Management APIs
        // For now, return a placeholder implementation
        query := fmt.Sprintf(`
        Resources
        | where resourceGroup == '%s'
        | project id, name, type, location, tags
        | join kind=leftouter (
                ResourceContainers
                | where type == 'microsoft.resources/subscriptions/resourcegroups'
                | project resourceGroup=name, subscriptionId
        ) on resourceGroup
        `, resourceGroup)

        resources, err := c.executeQuery(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to cost information (would need actual cost data)
        <span class="cov0" title="0">costs := make([]*ResourceCost, 0, len(resources))
        for _, resource := range resources </span><span class="cov0" title="0">{
                costs = append(costs, &amp;ResourceCost{
                        ResourceID:   resource.Id,
                        ResourceType: resource.Type,
                        Currency:     "USD",
                        // Actual cost data would come from Cost Management API
                })
        }</span>

        <span class="cov0" title="0">return costs, nil</span>
}

// executeQuery executes a KQL query with pagination support
func (c *ResourceGraphClient) executeQuery(ctx context.Context, query string) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        var allResources []*pb.ResourceRef
        skipToken := ""

        // Convert []string to []*string
        subscriptions := make([]*string, len(c.subscriptions))
        for i, sub := range c.subscriptions </span><span class="cov0" title="0">{
                subscriptions[i] = to.Ptr(sub)
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                request := armresourcegraph.QueryRequest{
                        Query:         to.Ptr(query),
                        Subscriptions: subscriptions,
                        Options: &amp;armresourcegraph.QueryRequestOptions{
                                ResultFormat: to.Ptr(armresourcegraph.ResultFormatObjectArray),
                                Top:          to.Ptr(int32(1000)), // Max results per page
                        },
                }

                if skipToken != "" </span><span class="cov0" title="0">{
                        request.Options.SkipToken = to.Ptr(skipToken)
                }</span>

                <span class="cov0" title="0">result, err := c.client.Resources(ctx, request, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to execute resource graph query: %w", err)
                }</span>

                // Parse results
                <span class="cov0" title="0">resources, err := c.parseQueryResults(&amp;result.QueryResponse)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">allResources = append(allResources, resources...)

                // Check if there are more results
                if result.SkipToken == nil || *result.SkipToken == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">skipToken = *result.SkipToken</span>
        }

        <span class="cov0" title="0">return allResources, nil</span>
}

// parseQueryResults parses Resource Graph query results
func (c *ResourceGraphClient) parseQueryResults(result *armresourcegraph.QueryResponse) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        if result.Data == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Resource Graph returns data as []interface{}
        <span class="cov0" title="0">data, ok := result.Data.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected result format")
        }</span>

        <span class="cov0" title="0">resources := make([]*pb.ResourceRef, 0, len(data))

        for _, item := range data </span><span class="cov0" title="0">{
                resourceMap, ok := item.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">resource := c.parseResourceMap(resourceMap)
                if resource != nil </span><span class="cov0" title="0">{
                        resources = append(resources, resource)
                }</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

// parseResourceMap converts a resource map to ResourceRef
func (c *ResourceGraphClient) parseResourceMap(resourceMap map[string]interface{}) *pb.ResourceRef <span class="cov0" title="0">{
        resource := &amp;pb.ResourceRef{
                BasicAttributes: make(map[string]string),
        }

        // Extract standard fields
        if id, ok := resourceMap["id"].(string); ok </span><span class="cov0" title="0">{
                resource.Id = id
        }</span>
        <span class="cov0" title="0">if name, ok := resourceMap["name"].(string); ok </span><span class="cov0" title="0">{
                resource.Name = name
        }</span>
        <span class="cov0" title="0">if resourceType, ok := resourceMap["type"].(string); ok </span><span class="cov0" title="0">{
                resource.Type = resourceType
                resource.Service = c.extractServiceFromType(resourceType)
        }</span>
        <span class="cov0" title="0">if location, ok := resourceMap["location"].(string); ok </span><span class="cov0" title="0">{
                resource.Region = location
        }</span>
        <span class="cov0" title="0">if rg, ok := resourceMap["resourceGroup"].(string); ok </span><span class="cov0" title="0">{
                resource.BasicAttributes["resource_group"] = rg
        }</span>
        <span class="cov0" title="0">if subID, ok := resourceMap["subscriptionId"].(string); ok </span><span class="cov0" title="0">{
                resource.BasicAttributes["subscription_id"] = subID
        }</span>

        // Extract tags
        <span class="cov0" title="0">if tags, ok := resourceMap["tags"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for k, v := range tags </span><span class="cov0" title="0">{
                        if strVal, ok := v.(string); ok </span><span class="cov0" title="0">{
                                resource.BasicAttributes["tag_"+k] = strVal
                        }</span>
                }
        }

        // Store properties as JSON
        <span class="cov0" title="0">if properties, ok := resourceMap["properties"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if propsJSON, err := json.Marshal(properties); err == nil </span><span class="cov0" title="0">{
                        resource.BasicAttributes["properties"] = string(propsJSON)
                }</span>
        }

        <span class="cov0" title="0">return resource</span>
}

// buildTypeFilter builds a KQL filter for resource types
func (c *ResourceGraphClient) buildTypeFilter(resourceTypes []string) string <span class="cov0" title="0">{
        if len(resourceTypes) == 0 </span><span class="cov0" title="0">{
                return "true"
        }</span>

        <span class="cov0" title="0">filters := make([]string, 0, len(resourceTypes))
        for _, rt := range resourceTypes </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf("type == '%s'", rt))
        }</span>

        <span class="cov0" title="0">return strings.Join(filters, " or ")</span>
}

// extractServiceFromType extracts service name from resource type
func (c *ResourceGraphClient) extractServiceFromType(resourceType string) string <span class="cov0" title="0">{
        parts := strings.Split(strings.ToLower(resourceType), "/")
        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                provider := parts[0]
                return strings.TrimPrefix(provider, "microsoft.")
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

// generateCacheKey generates a cache key for queries
func (c *ResourceGraphClient) generateCacheKey(query string, subscriptions []string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%x_%s", hashString(query), strings.Join(subscriptions, "_"))
}</span>

// QueryOptimizer optimizes KQL queries for performance
type QueryOptimizer struct {
        commonPatterns map[string]string
}

func NewQueryOptimizer() *QueryOptimizer <span class="cov0" title="0">{
        return &amp;QueryOptimizer{
                commonPatterns: map[string]string{
                        "vm_with_size": `
                                Resources
                                | where type == "microsoft.compute/virtualmachines"
                                | extend vmSize = properties.hardwareProfile.vmSize
                                | project id, name, location, resourceGroup, vmSize, properties
                        `,
                        "storage_with_tier": `
                                Resources
                                | where type == "microsoft.storage/storageaccounts"
                                | extend tier = sku.tier, kind = kind
                                | project id, name, location, resourceGroup, tier, kind, properties
                        `,
                        "network_with_subnets": `
                                Resources
                                | where type == "microsoft.network/virtualnetworks"
                                | extend subnetCount = array_length(properties.subnets)
                                | project id, name, location, resourceGroup, subnetCount, properties
                        `,
                },
        }
}</span>

func (o *QueryOptimizer) BuildQuery(filters map[string]interface{}) string <span class="cov0" title="0">{
        // Start with base query
        query := "Resources"

        // Add filters
        var whereConditions []string

        for key, value := range filters </span><span class="cov0" title="0">{
                switch key </span>{
                case "type":<span class="cov0" title="0">
                        if types, ok := value.([]string); ok </span><span class="cov0" title="0">{
                                typeFilters := make([]string, 0, len(types))
                                for _, t := range types </span><span class="cov0" title="0">{
                                        typeFilters = append(typeFilters, fmt.Sprintf("type == '%s'", t))
                                }</span>
                                <span class="cov0" title="0">whereConditions = append(whereConditions, "("+strings.Join(typeFilters, " or ")+")")</span>
                        } else<span class="cov0" title="0"> if typeStr, ok := value.(string); ok </span><span class="cov0" title="0">{
                                whereConditions = append(whereConditions, fmt.Sprintf("type == '%s'", typeStr))
                        }</span>
                case "location":<span class="cov0" title="0">
                        whereConditions = append(whereConditions, fmt.Sprintf("location == '%s'", value))</span>
                case "resourceGroup":<span class="cov0" title="0">
                        whereConditions = append(whereConditions, fmt.Sprintf("resourceGroup == '%s'", value))</span>
                case "tag":<span class="cov0" title="0">
                        if tagMap, ok := value.(map[string]string); ok </span><span class="cov0" title="0">{
                                for k, v := range tagMap </span><span class="cov0" title="0">{
                                        whereConditions = append(whereConditions, fmt.Sprintf("tags['%s'] == '%s'", k, v))
                                }</span>
                        }
                }
        }

        // Build query
        <span class="cov0" title="0">if len(whereConditions) &gt; 0 </span><span class="cov0" title="0">{
                query += "\n| where " + strings.Join(whereConditions, " and ")
        }</span>

        // Default projection
        <span class="cov0" title="0">query += "\n| project id, name, type, location, resourceGroup, subscriptionId, tags, properties"

        return query</span>
}

// QueryCache provides caching for Resource Graph queries
type QueryCache struct {
        cache map[string]*CacheEntry
        ttl   time.Duration
        mu    sync.RWMutex
}

type CacheEntry struct {
        Resources []*pb.ResourceRef
        Timestamp time.Time
}

func NewQueryCache(ttl time.Duration) *QueryCache <span class="cov0" title="0">{
        return &amp;QueryCache{
                cache: make(map[string]*CacheEntry),
                ttl:   ttl,
        }
}</span>

func (c *QueryCache) Get(key string) ([]*pb.ResourceRef, bool) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        entry, exists := c.cache[key]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">if time.Since(entry.Timestamp) &gt; c.ttl </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">return entry.Resources, true</span>
}

func (c *QueryCache) Set(key string, resources []*pb.ResourceRef) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.cache[key] = &amp;CacheEntry{
                Resources: resources,
                Timestamp: time.Now(),
        }
}</span>

// Supporting types
type ResourceChange struct {
        Timestamp          time.Time
        ChangeType         string
        TargetResourceID   string
        TargetResourceType string
        Changes            map[string]interface{}
}

type ResourceRelationship struct {
        SourceID     string
        TargetID     string
        RelationType string
        Direction    string
}

type ResourceCost struct {
        ResourceID   string
        ResourceType string
        Currency     string
        MonthlyCost  float64
        DailyCost    float64
        Tags         map[string]string
}

// parseChangeResults parses resource change results
func (c *ResourceGraphClient) parseChangeResults(result *armresourcegraph.QueryResponse) ([]*ResourceChange, error) <span class="cov0" title="0">{
        if result.Data == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">data, ok := result.Data.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected change result format")
        }</span>

        <span class="cov0" title="0">changes := make([]*ResourceChange, 0, len(data))

        for _, item := range data </span><span class="cov0" title="0">{
                changeMap, ok := item.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">change := &amp;ResourceChange{
                        Changes: make(map[string]interface{}),
                }

                // Parse change fields
                if ts, ok := changeMap["timestamp"].(string); ok </span><span class="cov0" title="0">{
                        if parsed, err := time.Parse(time.RFC3339, ts); err == nil </span><span class="cov0" title="0">{
                                change.Timestamp = parsed
                        }</span>
                }
                <span class="cov0" title="0">if ct, ok := changeMap["changeType"].(string); ok </span><span class="cov0" title="0">{
                        change.ChangeType = ct
                }</span>
                <span class="cov0" title="0">if id, ok := changeMap["targetResourceId"].(string); ok </span><span class="cov0" title="0">{
                        change.TargetResourceID = id
                }</span>
                <span class="cov0" title="0">if rt, ok := changeMap["targetResourceType"].(string); ok </span><span class="cov0" title="0">{
                        change.TargetResourceType = rt
                }</span>
                <span class="cov0" title="0">if ch, ok := changeMap["changes"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        change.Changes = ch
                }</span>

                <span class="cov0" title="0">changes = append(changes, change)</span>
        }

        <span class="cov0" title="0">return changes, nil</span>
}

// analyzeRelationships analyzes resources to find relationships
func (c *ResourceGraphClient) analyzeRelationships(resourceID string, resources []*pb.ResourceRef) []*ResourceRelationship <span class="cov0" title="0">{
        relationships := make([]*ResourceRelationship, 0)

        for _, resource := range resources </span><span class="cov0" title="0">{
                if resource.Id == resourceID </span><span class="cov0" title="0">{
                        continue</span> // Skip self
                }

                // Analyze properties for references
                <span class="cov0" title="0">if propsJSON, ok := resource.BasicAttributes["properties"]; ok </span><span class="cov0" title="0">{
                        var properties map[string]interface{}
                        if err := json.Unmarshal([]byte(propsJSON), &amp;properties); err == nil </span><span class="cov0" title="0">{
                                // Look for references to the resource ID
                                if c.containsReference(properties, resourceID) </span><span class="cov0" title="0">{
                                        relationships = append(relationships, &amp;ResourceRelationship{
                                                SourceID:     resource.Id,
                                                TargetID:     resourceID,
                                                RelationType: "references",
                                                Direction:    "outbound",
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return relationships</span>
}

// containsReference checks if a data structure contains a reference to a resource ID
func (c *ResourceGraphClient) containsReference(data interface{}, resourceID string) bool <span class="cov0" title="0">{
        switch v := data.(type) </span>{
        case string:<span class="cov0" title="0">
                return strings.Contains(v, resourceID)</span>
        case map[string]interface{}:<span class="cov0" title="0">
                for _, value := range v </span><span class="cov0" title="0">{
                        if c.containsReference(value, resourceID) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        case []interface{}:<span class="cov0" title="0">
                for _, item := range v </span><span class="cov0" title="0">{
                        if c.containsReference(item, resourceID) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

// hashString creates a simple hash of a string
func hashString(s string) uint32 <span class="cov0" title="0">{
        var h uint32
        for _, c := range s </span><span class="cov0" title="0">{
                h = h*31 + uint32(c)
        }</span>
        <span class="cov0" title="0">return h</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "strings"
        "sync"

        "github.com/Azure/azure-sdk-for-go/sdk/azcore"
        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/resources/armresources"
        pb "github.com/jlgore/corkscrew/internal/proto"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// AzureResourceScanner handles resource scanning operations
type AzureResourceScanner struct {
        credential      azcore.TokenCredential
        subscriptionID  string
        resourcesClient *armresources.Client
        clientFactory   *AzureClientFactory
        mu              sync.RWMutex
}

// NewAzureResourceScanner creates a new Azure resource scanner
func NewAzureResourceScanner(cred azcore.TokenCredential, subID string) *AzureResourceScanner <span class="cov0" title="0">{
        client, _ := armresources.NewClient(subID, cred, nil)
        return &amp;AzureResourceScanner{
                credential:      cred,
                subscriptionID:  subID,
                resourcesClient: client,
                clientFactory:   NewAzureClientFactory(cred, subID),
        }
}</span>

// ScanService scans resources for a specific service
func (s *AzureResourceScanner) ScanService(ctx context.Context, service string, filters map[string]string) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        log.Printf("Scanning service: %s with filters: %v", service, filters)
        
        // For now, let's scan all resources and filter by service
        // This is because Azure ARM filter syntax is limited
        allResources, err := s.scanWithFilter(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Map common service names to Azure resource provider namespaces
        <span class="cov0" title="0">serviceMapping := map[string][]string{
                "storage":   {"Microsoft.Storage/storageAccounts"},
                "compute":   {"Microsoft.Compute/virtualMachines", "Microsoft.Compute/disks", "Microsoft.Compute/virtualMachineScaleSets"},
                "network":   {"Microsoft.Network/virtualNetworks", "Microsoft.Network/networkInterfaces", "Microsoft.Network/publicIPAddresses", "Microsoft.Network/privateDnsZones", "Microsoft.Network/networkSecurityGroups"},
                "keyvault":  {"Microsoft.KeyVault/vaults"},
                "sql":       {"Microsoft.Sql/servers", "Microsoft.Sql/servers/databases"},
                "cosmosdb":  {"Microsoft.DocumentDB/databaseAccounts"},
                "appservice": {"Microsoft.Web/sites", "Microsoft.Web/serverFarms"},
                "functions": {"Microsoft.Web/sites"},
                "aks":       {"Microsoft.ContainerService/managedClusters"},
                "containerregistry": {"Microsoft.ContainerRegistry/registries"},
                "monitor":   {"Microsoft.Insights/components", "Microsoft.OperationalInsights/workspaces"},
                "eventhub":  {"Microsoft.EventHub/namespaces"},
                "managedidentity": {"Microsoft.ManagedIdentity/userAssignedIdentities"},
        }
        
        // Get the Azure resource types for this service
        resourceTypes := serviceMapping[strings.ToLower(service)]
        if len(resourceTypes) == 0 </span><span class="cov0" title="0">{
                // If no mapping, try to match by provider namespace
                resourceTypes = []string{fmt.Sprintf("Microsoft.%s/", strings.Title(service))}
        }</span>
        
        // Filter resources by type
        <span class="cov0" title="0">var filteredResources []*pb.ResourceRef
        for _, resource := range allResources </span><span class="cov0" title="0">{
                for _, targetType := range resourceTypes </span><span class="cov0" title="0">{
                        if strings.HasPrefix(resource.Type, targetType) </span><span class="cov0" title="0">{
                                // Apply additional filters
                                if rgFilter, ok := filters["resource_group"]; ok </span><span class="cov0" title="0">{
                                        if rg, ok := resource.BasicAttributes["resource_group"]; ok &amp;&amp; rg != rgFilter </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                }
                                <span class="cov0" title="0">if locationFilter, ok := filters["location"]; ok </span><span class="cov0" title="0">{
                                        if resource.Region != locationFilter </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                }
                                <span class="cov0" title="0">filteredResources = append(filteredResources, resource)
                                break</span>
                        }
                }
        }
        
        <span class="cov0" title="0">log.Printf("Found %d resources for service %s", len(filteredResources), service)
        return filteredResources, nil</span>
}

// ScanAllResources scans all resources using ARM API
func (s *AzureResourceScanner) ScanAllResources(ctx context.Context, filters map[string]string) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        var filter string
        var filterParts []string

        if rgFilter, ok := filters["resource_group"]; ok </span><span class="cov0" title="0">{
                filterParts = append(filterParts, fmt.Sprintf("resourceGroup eq '%s'", rgFilter))
        }</span>

        <span class="cov0" title="0">if locationFilter, ok := filters["location"]; ok </span><span class="cov0" title="0">{
                filterParts = append(filterParts, fmt.Sprintf("location eq '%s'", locationFilter))
        }</span>

        <span class="cov0" title="0">if len(filterParts) &gt; 0 </span><span class="cov0" title="0">{
                filter = strings.Join(filterParts, " and ")
        }</span>

        <span class="cov0" title="0">return s.scanWithFilter(ctx, filter)</span>
}

// ScanServiceForResources scans a service and returns full Resource objects
func (s *AzureResourceScanner) ScanServiceForResources(ctx context.Context, service string, filters map[string]string) ([]*pb.Resource, error) <span class="cov0" title="0">{
        resourceRefs, err := s.ScanService(ctx, service, filters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert ResourceRef to Resource
        <span class="cov0" title="0">resources := make([]*pb.Resource, 0, len(resourceRefs))
        for _, ref := range resourceRefs </span><span class="cov0" title="0">{
                resource := &amp;pb.Resource{
                        Provider:     "azure",
                        Service:      ref.Service,
                        Type:         ref.Type,
                        Id:           ref.Id,
                        Name:         ref.Name,
                        Region:       ref.Region,
                        Tags:         make(map[string]string),
                        DiscoveredAt: timestamppb.Now(),
                }

                // Extract metadata
                if ref.BasicAttributes != nil </span><span class="cov0" title="0">{
                        if rg, ok := ref.BasicAttributes["resource_group"]; ok </span><span class="cov0" title="0">{
                                resource.ParentId = rg
                        }</span>
                        <span class="cov0" title="0">if subID, ok := ref.BasicAttributes["subscription_id"]; ok </span><span class="cov0" title="0">{
                                resource.AccountId = subID
                        }</span>

                        // Extract tags
                        <span class="cov0" title="0">for k, v := range ref.BasicAttributes </span><span class="cov0" title="0">{
                                if strings.HasPrefix(k, "tag_") </span><span class="cov0" title="0">{
                                        tagName := strings.TrimPrefix(k, "tag_")
                                        resource.Tags[tagName] = v
                                }</span>
                        }

                        // Store properties as raw data
                        <span class="cov0" title="0">if props, ok := ref.BasicAttributes["properties"]; ok </span><span class="cov0" title="0">{
                                resource.RawData = props
                        }</span>
                }
                
                // Extract relationships from the resource
                <span class="cov0" title="0">relationships := s.extractRelationshipsFromResource(resource, ref)
                for _, rel := range relationships </span><span class="cov0" title="0">{
                        resource.Relationships = append(resource.Relationships, rel)
                }</span>

                <span class="cov0" title="0">resources = append(resources, resource)</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

// DescribeResource provides detailed information about a specific resource
func (s *AzureResourceScanner) DescribeResource(ctx context.Context, resourceRef *pb.ResourceRef) (*pb.Resource, error) <span class="cov0" title="0">{
        if resourceRef == nil || resourceRef.Id == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("resource reference is required")
        }</span>

        // Get resource details using ARM API
        <span class="cov0" title="0">result, err := s.resourcesClient.GetByID(ctx, resourceRef.Id, "2021-04-01", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get resource %s: %w", resourceRef.Id, err)
        }</span>

        <span class="cov0" title="0">resource := &amp;pb.Resource{
                Provider:     "azure",
                Service:      resourceRef.Service,
                Type:         resourceRef.Type,
                Id:           resourceRef.Id,
                Name:         resourceRef.Name,
                Region:       resourceRef.Region,
                Tags:         make(map[string]string),
                DiscoveredAt: timestamppb.Now(),
        }

        // Extract detailed information
        if result.ID != nil </span><span class="cov0" title="0">{
                resource.Id = *result.ID
        }</span>
        <span class="cov0" title="0">if result.Name != nil </span><span class="cov0" title="0">{
                resource.Name = *result.Name
        }</span>
        <span class="cov0" title="0">if result.Type != nil </span><span class="cov0" title="0">{
                resource.Type = *result.Type
                resource.Service = s.extractServiceFromType(*result.Type)
        }</span>
        <span class="cov0" title="0">if result.Location != nil </span><span class="cov0" title="0">{
                resource.Region = *result.Location
        }</span>

        // Extract resource group from ID
        <span class="cov0" title="0">if resourceGroup := s.extractResourceGroupFromID(resource.Id); resourceGroup != "" </span><span class="cov0" title="0">{
                resource.ParentId = resourceGroup
        }</span>

        // Extract subscription ID
        <span class="cov0" title="0">resource.AccountId = s.subscriptionID

        // Extract tags
        if result.Tags != nil </span><span class="cov0" title="0">{
                for k, v := range result.Tags </span><span class="cov0" title="0">{
                        if v != nil </span><span class="cov0" title="0">{
                                resource.Tags[k] = *v
                        }</span>
                }
        }

        // Store properties as raw data
        <span class="cov0" title="0">if result.Properties != nil </span><span class="cov0" title="0">{
                if propsJSON, err := json.Marshal(result.Properties); err == nil </span><span class="cov0" title="0">{
                        resource.RawData = string(propsJSON)
                }</span>
        }

        <span class="cov0" title="0">return resource, nil</span>
}

// StreamScanResources streams resources as they are discovered
func (s *AzureResourceScanner) StreamScanResources(ctx context.Context, services []string, resourceChan chan&lt;- *pb.Resource) error <span class="cov0" title="0">{
        defer close(resourceChan)

        for _, service := range services </span><span class="cov0" title="0">{
                resources, err := s.ScanServiceForResources(ctx, service, nil)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to scan service %s: %v", service, err)
                        continue</span>
                }

                <span class="cov0" title="0">for _, resource := range resources </span><span class="cov0" title="0">{
                        select </span>{
                        case resourceChan &lt;- resource:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// scanWithFilter scans resources with the given OData filter
func (s *AzureResourceScanner) scanWithFilter(ctx context.Context, filter string) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        var resources []*pb.ResourceRef

        options := &amp;armresources.ClientListOptions{}
        if filter != "" </span><span class="cov0" title="0">{
                options.Filter = &amp;filter
        }</span>

        <span class="cov0" title="0">pager := s.resourcesClient.NewListPager(options)

        for pager.More() </span><span class="cov0" title="0">{
                page, err := pager.NextPage(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to list resources: %w", err)
                }</span>

                <span class="cov0" title="0">for _, resource := range page.Value </span><span class="cov0" title="0">{
                        ref := s.convertToResourceRef(*resource)
                        if ref != nil </span><span class="cov0" title="0">{
                                resources = append(resources, ref)
                        }</span>
                }
        }

        <span class="cov0" title="0">return resources, nil</span>
}

// convertToResourceRef converts ARM resource to ResourceRef
func (s *AzureResourceScanner) convertToResourceRef(resource armresources.GenericResourceExpanded) *pb.ResourceRef <span class="cov0" title="0">{
        if resource.ID == nil || resource.Name == nil || resource.Type == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">ref := &amp;pb.ResourceRef{
                Id:              *resource.ID,
                Name:            *resource.Name,
                Type:            *resource.Type,
                Service:         s.extractServiceFromType(*resource.Type),
                BasicAttributes: make(map[string]string),
        }

        // Extract location
        if resource.Location != nil </span><span class="cov0" title="0">{
                ref.Region = *resource.Location
        }</span>

        // Extract resource group from ID
        <span class="cov0" title="0">if resourceGroup := s.extractResourceGroupFromID(*resource.ID); resourceGroup != "" </span><span class="cov0" title="0">{
                ref.BasicAttributes["resource_group"] = resourceGroup
        }</span>

        // Add subscription ID
        <span class="cov0" title="0">ref.BasicAttributes["subscription_id"] = s.subscriptionID

        // Add tags as metadata
        if resource.Tags != nil </span><span class="cov0" title="0">{
                for k, v := range resource.Tags </span><span class="cov0" title="0">{
                        if v != nil </span><span class="cov0" title="0">{
                                ref.BasicAttributes["tag_"+k] = *v
                        }</span>
                }
        }

        // Store properties as JSON
        <span class="cov0" title="0">if resource.Properties != nil </span><span class="cov0" title="0">{
                if propsJSON, err := json.Marshal(resource.Properties); err == nil </span><span class="cov0" title="0">{
                        ref.BasicAttributes["properties"] = string(propsJSON)
                }</span>
        }

        <span class="cov0" title="0">return ref</span>
}

// extractServiceFromType extracts service name from resource type
func (s *AzureResourceScanner) extractServiceFromType(resourceType string) string <span class="cov0" title="0">{
        // Microsoft.Compute/virtualMachines -&gt; compute
        parts := strings.Split(resourceType, "/")
        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                provider := parts[0]
                return strings.ToLower(strings.TrimPrefix(provider, "Microsoft."))
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

// extractResourceGroupFromID extracts resource group name from resource ID
func (s *AzureResourceScanner) extractResourceGroupFromID(resourceID string) string <span class="cov0" title="0">{
        // Format: /subscriptions/{sub}/resourceGroups/{rg}/providers/{provider}/{type}/{name}
        parts := strings.Split(resourceID, "/")
        for i, part := range parts </span><span class="cov0" title="0">{
                if strings.EqualFold(part, "resourceGroups") &amp;&amp; i+1 &lt; len(parts) </span><span class="cov0" title="0">{
                        return parts[i+1]
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// ScanResourceGroup scans all resources in a specific resource group
func (s *AzureResourceScanner) ScanResourceGroup(ctx context.Context, resourceGroup string) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        filter := fmt.Sprintf("resourceGroup eq '%s'", resourceGroup)
        return s.scanWithFilter(ctx, filter)
}</span>

// ScanByResourceType scans resources of a specific type
func (s *AzureResourceScanner) ScanByResourceType(ctx context.Context, resourceType string) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        filter := fmt.Sprintf("resourceType eq '%s'", resourceType)
        return s.scanWithFilter(ctx, filter)
}</span>

// ScanByLocation scans resources in a specific location
func (s *AzureResourceScanner) ScanByLocation(ctx context.Context, location string) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        filter := fmt.Sprintf("location eq '%s'", location)
        return s.scanWithFilter(ctx, filter)
}</span>

// ScanByTags scans resources with specific tags
func (s *AzureResourceScanner) ScanByTags(ctx context.Context, tags map[string]string) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        // ARM API has limited tag filtering capabilities
        // This would need to be enhanced with post-filtering
        resources, err := s.scanWithFilter(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Filter by tags
        <span class="cov0" title="0">var filtered []*pb.ResourceRef
        for _, resource := range resources </span><span class="cov0" title="0">{
                if s.matchesTags(resource, tags) </span><span class="cov0" title="0">{
                        filtered = append(filtered, resource)
                }</span>
        }

        <span class="cov0" title="0">return filtered, nil</span>
}

// matchesTags checks if a resource matches the specified tags
func (s *AzureResourceScanner) matchesTags(resource *pb.ResourceRef, tags map[string]string) bool <span class="cov0" title="0">{
        if resource.BasicAttributes == nil </span><span class="cov0" title="0">{
                return len(tags) == 0
        }</span>

        <span class="cov0" title="0">for key, value := range tags </span><span class="cov0" title="0">{
                tagKey := "tag_" + key
                if resourceValue, exists := resource.BasicAttributes[tagKey]; !exists || resourceValue != value </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// GetResourceCount returns the count of resources for a service
func (s *AzureResourceScanner) GetResourceCount(ctx context.Context, service string) (int, error) <span class="cov0" title="0">{
        resources, err := s.ScanService(ctx, service, nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return len(resources), nil</span>
}

// GetResourcesByProvider returns resources grouped by provider
func (s *AzureResourceScanner) GetResourcesByProvider(ctx context.Context) (map[string][]*pb.ResourceRef, error) <span class="cov0" title="0">{
        allResources, err := s.ScanAllResources(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">grouped := make(map[string][]*pb.ResourceRef)
        for _, resource := range allResources </span><span class="cov0" title="0">{
                provider := s.extractProviderFromType(resource.Type)
                grouped[provider] = append(grouped[provider], resource)
        }</span>

        <span class="cov0" title="0">return grouped, nil</span>
}

// extractProviderFromType extracts provider namespace from resource type
func (s *AzureResourceScanner) extractProviderFromType(resourceType string) string <span class="cov0" title="0">{
        // Microsoft.Compute/virtualMachines -&gt; Microsoft.Compute
        parts := strings.Split(resourceType, "/")
        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                return parts[0]
        }</span>
        <span class="cov0" title="0">return "unknown"</span>
}

// ValidateResourceAccess checks if the scanner can access a specific resource
func (s *AzureResourceScanner) ValidateResourceAccess(ctx context.Context, resourceID string) error <span class="cov0" title="0">{
        _, err := s.resourcesClient.GetByID(ctx, resourceID, "2021-04-01", nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot access resource %s: %w", resourceID, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetResourceMetrics would integrate with Azure Monitor to get resource metrics
func (s *AzureResourceScanner) GetResourceMetrics(ctx context.Context, resourceID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        // This would integrate with Azure Monitor APIs
        // For now, return placeholder
        return map[string]interface{}{
                "resource_id": resourceID,
                "metrics":     "not_implemented",
        }, nil
}</span>

// GetResourceDependencies analyzes resource dependencies
func (s *AzureResourceScanner) GetResourceDependencies(ctx context.Context, resourceID string) ([]*pb.ResourceRef, error) <span class="cov0" title="0">{
        // This would analyze ARM template dependencies or use Resource Graph
        // For now, return empty list
        return []*pb.ResourceRef{}, nil
}</span>

// BatchGetResources gets multiple resources by their IDs
func (s *AzureResourceScanner) BatchGetResources(ctx context.Context, resourceIDs []string) ([]*pb.Resource, error) <span class="cov0" title="0">{
        resources := make([]*pb.Resource, 0, len(resourceIDs))

        // Process in parallel with limited concurrency
        semaphore := make(chan struct{}, 10) // Limit to 10 concurrent requests
        var wg sync.WaitGroup
        var mu sync.Mutex
        var errors []error

        for _, resourceID := range resourceIDs </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(id string) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        semaphore &lt;- struct{}{}        // Acquire
                        defer func() </span><span class="cov0" title="0">{ &lt;-semaphore }</span>() // Release

                        <span class="cov0" title="0">resourceRef := &amp;pb.ResourceRef{Id: id}
                        resource, err := s.DescribeResource(ctx, resourceRef)
                        if err != nil </span><span class="cov0" title="0">{
                                mu.Lock()
                                errors = append(errors, fmt.Errorf("failed to get resource %s: %w", id, err))
                                mu.Unlock()
                                return
                        }</span>

                        <span class="cov0" title="0">mu.Lock()
                        resources = append(resources, resource)
                        mu.Unlock()</span>
                }(resourceID)
        }

        <span class="cov0" title="0">wg.Wait()

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                // Return partial results with error information
                log.Printf("Batch get completed with %d errors out of %d resources", len(errors), len(resourceIDs))
        }</span>

        <span class="cov0" title="0">return resources, nil</span>
}

// extractRelationshipsFromResource extracts relationships from an Azure resource
func (s *AzureResourceScanner) extractRelationshipsFromResource(resource *pb.Resource, ref *pb.ResourceRef) []*pb.Relationship <span class="cov0" title="0">{
        relationships := []*pb.Relationship{}
        
        // Extract parent-child relationships from resource ID structure
        // Azure resource IDs follow pattern: /subscriptions/{sub}/resourceGroups/{rg}/providers/{provider}/{type}/{name}
        if resource.ParentId != "" &amp;&amp; resource.ParentId != resource.Id </span><span class="cov0" title="0">{
                relationships = append(relationships, &amp;pb.Relationship{
                        TargetId:         resource.ParentId,
                        TargetType:       "resourceGroup",
                        RelationshipType: "child_of",
                })
        }</span>
        
        // Extract relationships from properties if available
        <span class="cov0" title="0">if ref.BasicAttributes != nil &amp;&amp; ref.BasicAttributes["properties"] != "" </span><span class="cov0" title="0">{
                var props map[string]interface{}
                if err := json.Unmarshal([]byte(ref.BasicAttributes["properties"]), &amp;props); err == nil </span><span class="cov0" title="0">{
                        // Virtual Machine specific relationships
                        if strings.Contains(resource.Type, "Microsoft.Compute/virtualMachines") </span><span class="cov0" title="0">{
                                s.extractVMRelationships(resource.Id, props, &amp;relationships)
                        }</span>
                        
                        // Storage Account relationships
                        <span class="cov0" title="0">if strings.Contains(resource.Type, "Microsoft.Storage/storageAccounts") </span><span class="cov0" title="0">{
                                s.extractStorageRelationships(resource.Id, props, &amp;relationships)
                        }</span>
                        
                        // Virtual Network relationships
                        <span class="cov0" title="0">if strings.Contains(resource.Type, "Microsoft.Network/virtualNetworks") </span><span class="cov0" title="0">{
                                s.extractVNetRelationships(resource.Id, props, &amp;relationships)
                        }</span>
                        
                        // Network Interface relationships
                        <span class="cov0" title="0">if strings.Contains(resource.Type, "Microsoft.Network/networkInterfaces") </span><span class="cov0" title="0">{
                                s.extractNICRelationships(resource.Id, props, &amp;relationships)
                        }</span>
                        
                        // Key Vault relationships
                        <span class="cov0" title="0">if strings.Contains(resource.Type, "Microsoft.KeyVault/vaults") </span><span class="cov0" title="0">{
                                s.extractKeyVaultRelationships(resource.Id, props, &amp;relationships)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return relationships</span>
}

// Helper methods for extracting specific resource type relationships

func (s *AzureResourceScanner) extractVMRelationships(vmID string, props map[string]interface{}, relationships *[]*pb.Relationship) <span class="cov0" title="0">{
        // Network interfaces
        if netProfile, ok := props["networkProfile"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if interfaces, ok := netProfile["networkInterfaces"].([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, nic := range interfaces </span><span class="cov0" title="0">{
                                if nicMap, ok := nic.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if nicID, ok := nicMap["id"].(string); ok </span><span class="cov0" title="0">{
                                                *relationships = append(*relationships, &amp;pb.Relationship{
                                                        TargetId:         nicID,
                                                        TargetType:       "Microsoft.Network/networkInterfaces",
                                                        RelationshipType: "uses",
                                                })
                                        }</span>
                                }
                        }
                }
        }
        
        // Availability Set
        <span class="cov0" title="0">if availSet, ok := props["availabilitySet"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if availSetID, ok := availSet["id"].(string); ok </span><span class="cov0" title="0">{
                        *relationships = append(*relationships, &amp;pb.Relationship{
                                TargetId:         availSetID,
                                TargetType:       "Microsoft.Compute/availabilitySets",
                                RelationshipType: "member_of",
                        })
                }</span>
        }
        
        // Storage Profile - OS and Data Disks
        <span class="cov0" title="0">if storageProfile, ok := props["storageProfile"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                // OS Disk
                if osDisk, ok := storageProfile["osDisk"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if managedDisk, ok := osDisk["managedDisk"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if diskID, ok := managedDisk["id"].(string); ok </span><span class="cov0" title="0">{
                                        *relationships = append(*relationships, &amp;pb.Relationship{
                                                TargetId:         diskID,
                                                TargetType:       "Microsoft.Compute/disks",
                                                RelationshipType: "uses",
                                        })
                                }</span>
                        }
                }
                
                // Data Disks
                <span class="cov0" title="0">if dataDisks, ok := storageProfile["dataDisks"].([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, disk := range dataDisks </span><span class="cov0" title="0">{
                                if diskMap, ok := disk.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if managedDisk, ok := diskMap["managedDisk"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if diskID, ok := managedDisk["id"].(string); ok </span><span class="cov0" title="0">{
                                                        *relationships = append(*relationships, &amp;pb.Relationship{
                                                                TargetId:         diskID,
                                                                TargetType:       "Microsoft.Compute/disks",
                                                                RelationshipType: "uses",
                                                        })
                                                }</span>
                                        }
                                }
                        }
                }
        }
}

func (s *AzureResourceScanner) extractStorageRelationships(storageID string, props map[string]interface{}, relationships *[]*pb.Relationship) <span class="cov0" title="0">{
        // Private endpoints
        if privateEndpoints, ok := props["privateEndpointConnections"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, pe := range privateEndpoints </span><span class="cov0" title="0">{
                        if peMap, ok := pe.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if peProps, ok := peMap["properties"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if privateEndpoint, ok := peProps["privateEndpoint"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if peID, ok := privateEndpoint["id"].(string); ok </span><span class="cov0" title="0">{
                                                        *relationships = append(*relationships, &amp;pb.Relationship{
                                                                TargetId:         peID,
                                                                TargetType:       "Microsoft.Network/privateEndpoints",
                                                                RelationshipType: "connected_to",
                                                        })
                                                }</span>
                                        }
                                }
                        }
                }
        }
}

func (s *AzureResourceScanner) extractVNetRelationships(vnetID string, props map[string]interface{}, relationships *[]*pb.Relationship) <span class="cov0" title="0">{
        // Subnets (parent-child relationship)
        if subnets, ok := props["subnets"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, subnet := range subnets </span><span class="cov0" title="0">{
                        if subnetMap, ok := subnet.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if subnetID, ok := subnetMap["id"].(string); ok </span><span class="cov0" title="0">{
                                        *relationships = append(*relationships, &amp;pb.Relationship{
                                                TargetId:         subnetID,
                                                TargetType:       "Microsoft.Network/virtualNetworks/subnets",
                                                RelationshipType: "contains",
                                        })
                                }</span>
                        }
                }
        }
        
        // VNet Peerings
        <span class="cov0" title="0">if peerings, ok := props["virtualNetworkPeerings"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, peering := range peerings </span><span class="cov0" title="0">{
                        if peerMap, ok := peering.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if peerProps, ok := peerMap["properties"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if remoteVnet, ok := peerProps["remoteVirtualNetwork"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if vnetID, ok := remoteVnet["id"].(string); ok </span><span class="cov0" title="0">{
                                                        *relationships = append(*relationships, &amp;pb.Relationship{
                                                                TargetId:         vnetID,
                                                                TargetType:       "Microsoft.Network/virtualNetworks",
                                                                RelationshipType: "peered_with",
                                                        })
                                                }</span>
                                        }
                                }
                        }
                }
        }
}

func (s *AzureResourceScanner) extractNICRelationships(nicID string, props map[string]interface{}, relationships *[]*pb.Relationship) <span class="cov0" title="0">{
        // IP Configurations - Subnet and Public IP relationships
        if ipConfigs, ok := props["ipConfigurations"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, ipConfig := range ipConfigs </span><span class="cov0" title="0">{
                        if ipConfigMap, ok := ipConfig.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if ipConfigProps, ok := ipConfigMap["properties"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        // Subnet relationship
                                        if subnet, ok := ipConfigProps["subnet"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if subnetID, ok := subnet["id"].(string); ok </span><span class="cov0" title="0">{
                                                        *relationships = append(*relationships, &amp;pb.Relationship{
                                                                TargetId:         subnetID,
                                                                TargetType:       "Microsoft.Network/virtualNetworks/subnets",
                                                                RelationshipType: "attached_to",
                                                        })
                                                }</span>
                                        }
                                        
                                        // Public IP relationship
                                        <span class="cov0" title="0">if publicIP, ok := ipConfigProps["publicIPAddress"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                if publicIPID, ok := publicIP["id"].(string); ok </span><span class="cov0" title="0">{
                                                        *relationships = append(*relationships, &amp;pb.Relationship{
                                                                TargetId:         publicIPID,
                                                                TargetType:       "Microsoft.Network/publicIPAddresses",
                                                                RelationshipType: "uses",
                                                        })
                                                }</span>
                                        }
                                }
                        }
                }
        }
        
        // Network Security Group
        <span class="cov0" title="0">if nsg, ok := props["networkSecurityGroup"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if nsgID, ok := nsg["id"].(string); ok </span><span class="cov0" title="0">{
                        *relationships = append(*relationships, &amp;pb.Relationship{
                                TargetId:         nsgID,
                                TargetType:       "Microsoft.Network/networkSecurityGroups",
                                RelationshipType: "protected_by",
                        })
                }</span>
        }
}

func (s *AzureResourceScanner) extractKeyVaultRelationships(kvID string, props map[string]interface{}, relationships *[]*pb.Relationship) <span class="cov0" title="0">{
        // Access policies could reference other resources
        if accessPolicies, ok := props["accessPolicies"].([]interface{}); ok </span><span class="cov0" title="0">{
                for _, policy := range accessPolicies </span><span class="cov0" title="0">{
                        if policyMap, ok := policy.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if objectID, ok := policyMap["objectId"].(string); ok </span><span class="cov0" title="0">{
                                        // This could be a user, group, or service principal
                                        *relationships = append(*relationships, &amp;pb.Relationship{
                                                TargetId:         objectID,
                                                TargetType:       "identity",
                                                RelationshipType: "grants_access_to",
                                        })
                                }</span>
                        }
                }
        }
}

</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "fmt"
        "strings"
        "sync"
)

// TableSchema represents a database table schema
type TableSchema struct {
        TableName string
        Columns   []*ColumnDefinition
        Indexes   []string
}

// ColumnDefinition represents a database column definition
type ColumnDefinition struct {
        Name       string
        Type       string
        Nullable   bool
        PrimaryKey bool
}

// AzureSchemaGenerator generates database schemas for Azure resources
type AzureSchemaGenerator struct {
        schemaCache map[string]*TableSchema
        mu          sync.RWMutex
}

// NewAzureSchemaGenerator creates a new Azure schema generator
func NewAzureSchemaGenerator() *AzureSchemaGenerator <span class="cov8" title="1">{
        return &amp;AzureSchemaGenerator{
                schemaCache: make(map[string]*TableSchema),
        }
}</span>

// GenerateSchema generates a database schema for a resource type
func (g *AzureSchemaGenerator) GenerateSchema(resourceType ResourceTypeInfo) *TableSchema <span class="cov8" title="1">{
        g.mu.Lock()
        defer g.mu.Unlock()

        // Check cache
        tableName := g.generateTableName(resourceType.ResourceType)
        if schema, exists := g.schemaCache[tableName]; exists </span><span class="cov0" title="0">{
                return schema
        }</span>

        // Generate schema based on resource type
        <span class="cov8" title="1">schema := &amp;TableSchema{
                TableName: tableName,
                Columns: []*ColumnDefinition{
                        // Common Azure resource columns
                        {Name: "id", Type: "VARCHAR", PrimaryKey: true},
                        {Name: "name", Type: "VARCHAR", Nullable: false},
                        {Name: "type", Type: "VARCHAR", Nullable: false},
                        {Name: "location", Type: "VARCHAR", Nullable: false},
                        {Name: "resource_group", Type: "VARCHAR", Nullable: false},
                        {Name: "subscription_id", Type: "VARCHAR", Nullable: false},
                        {Name: "properties", Type: "JSON", Nullable: true},
                        {Name: "tags", Type: "JSON", Nullable: true},
                        {Name: "created_time", Type: "TIMESTAMP", Nullable: true},
                        {Name: "changed_time", Type: "TIMESTAMP", Nullable: true},
                        {Name: "provisioning_state", Type: "VARCHAR", Nullable: true},
                        {Name: "discovered_at", Type: "TIMESTAMP", Nullable: false},
                },
                Indexes: []string{
                        "idx_resource_group",
                        "idx_location",
                        "idx_type",
                        "idx_provisioning_state",
                },
        }

        // Add resource-specific columns based on type
        g.addResourceSpecificColumns(schema, resourceType.ResourceType)

        // Cache the schema
        g.schemaCache[tableName] = schema

        return schema</span>
}

// generateTableName creates a table name from resource type
func (g *AzureSchemaGenerator) generateTableName(resourceType string) string <span class="cov8" title="1">{
        // Microsoft.Compute/virtualMachines -&gt; azure_compute_virtualmachines
        cleaned := strings.ToLower(resourceType)
        cleaned = strings.ReplaceAll(cleaned, "microsoft.", "azure_")
        cleaned = strings.ReplaceAll(cleaned, "/", "_")
        cleaned = strings.ReplaceAll(cleaned, "-", "_")
        cleaned = strings.ReplaceAll(cleaned, ".", "_")
        return cleaned
}</span>

// addResourceSpecificColumns adds columns specific to certain resource types
func (g *AzureSchemaGenerator) addResourceSpecificColumns(schema *TableSchema, resourceType string) <span class="cov8" title="1">{
        // Add columns specific to certain resource types
        switch resourceType </span>{
        case "Microsoft.Compute/virtualMachines":<span class="cov8" title="1">
                schema.Columns = append(schema.Columns, []*ColumnDefinition{
                        {Name: "vm_size", Type: "VARCHAR", Nullable: true},
                        {Name: "os_type", Type: "VARCHAR", Nullable: true},
                        {Name: "os_disk_type", Type: "VARCHAR", Nullable: true},
                        {Name: "availability_set_id", Type: "VARCHAR", Nullable: true},
                        {Name: "network_interface_ids", Type: "JSON", Nullable: true},
                        {Name: "power_state", Type: "VARCHAR", Nullable: true},
                }...)
                schema.Indexes = append(schema.Indexes, "idx_vm_size", "idx_os_type", "idx_power_state")</span>

        case "Microsoft.Storage/storageAccounts":<span class="cov8" title="1">
                schema.Columns = append(schema.Columns, []*ColumnDefinition{
                        {Name: "account_type", Type: "VARCHAR", Nullable: true},
                        {Name: "access_tier", Type: "VARCHAR", Nullable: true},
                        {Name: "encryption_enabled", Type: "BOOLEAN", Nullable: true},
                        {Name: "https_traffic_only", Type: "BOOLEAN", Nullable: true},
                        {Name: "blob_public_access", Type: "BOOLEAN", Nullable: true},
                        {Name: "primary_endpoints", Type: "JSON", Nullable: true},
                }...)
                schema.Indexes = append(schema.Indexes, "idx_account_type", "idx_access_tier")</span>

        case "Microsoft.Network/virtualNetworks":<span class="cov8" title="1">
                schema.Columns = append(schema.Columns, []*ColumnDefinition{
                        {Name: "address_space", Type: "JSON", Nullable: true},
                        {Name: "dns_servers", Type: "JSON", Nullable: true},
                        {Name: "subnet_count", Type: "INTEGER", Nullable: true},
                        {Name: "peering_count", Type: "INTEGER", Nullable: true},
                }...)
                schema.Indexes = append(schema.Indexes, "idx_subnet_count")</span>

        case "Microsoft.Network/networkSecurityGroups":<span class="cov0" title="0">
                schema.Columns = append(schema.Columns, []*ColumnDefinition{
                        {Name: "security_rules_count", Type: "INTEGER", Nullable: true},
                        {Name: "default_rules_count", Type: "INTEGER", Nullable: true},
                        {Name: "associated_subnets", Type: "JSON", Nullable: true},
                        {Name: "associated_interfaces", Type: "JSON", Nullable: true},
                }...)</span>

        case "Microsoft.Web/sites":<span class="cov8" title="1">
                schema.Columns = append(schema.Columns, []*ColumnDefinition{
                        {Name: "app_service_plan_id", Type: "VARCHAR", Nullable: true},
                        {Name: "runtime_stack", Type: "VARCHAR", Nullable: true},
                        {Name: "https_only", Type: "BOOLEAN", Nullable: true},
                        {Name: "client_affinity_enabled", Type: "BOOLEAN", Nullable: true},
                        {Name: "default_hostname", Type: "VARCHAR", Nullable: true},
                        {Name: "state", Type: "VARCHAR", Nullable: true},
                }...)
                schema.Indexes = append(schema.Indexes, "idx_app_service_plan_id", "idx_runtime_stack", "idx_state")</span>

        case "Microsoft.Sql/servers":<span class="cov8" title="1">
                schema.Columns = append(schema.Columns, []*ColumnDefinition{
                        {Name: "administrator_login", Type: "VARCHAR", Nullable: true},
                        {Name: "version", Type: "VARCHAR", Nullable: true},
                        {Name: "fully_qualified_domain_name", Type: "VARCHAR", Nullable: true},
                        {Name: "public_network_access", Type: "VARCHAR", Nullable: true},
                }...)
                schema.Indexes = append(schema.Indexes, "idx_version", "idx_public_network_access")</span>

        case "Microsoft.Sql/servers/databases":<span class="cov0" title="0">
                schema.Columns = append(schema.Columns, []*ColumnDefinition{
                        {Name: "server_name", Type: "VARCHAR", Nullable: true},
                        {Name: "database_id", Type: "VARCHAR", Nullable: true},
                        {Name: "edition", Type: "VARCHAR", Nullable: true},
                        {Name: "service_objective", Type: "VARCHAR", Nullable: true},
                        {Name: "collation", Type: "VARCHAR", Nullable: true},
                        {Name: "max_size_bytes", Type: "BIGINT", Nullable: true},
                }...)
                schema.Indexes = append(schema.Indexes, "idx_server_name", "idx_edition", "idx_service_objective")</span>

        case "Microsoft.KeyVault/vaults":<span class="cov8" title="1">
                schema.Columns = append(schema.Columns, []*ColumnDefinition{
                        {Name: "vault_uri", Type: "VARCHAR", Nullable: true},
                        {Name: "tenant_id", Type: "VARCHAR", Nullable: true},
                        {Name: "sku_name", Type: "VARCHAR", Nullable: true},
                        {Name: "enabled_for_deployment", Type: "BOOLEAN", Nullable: true},
                        {Name: "enabled_for_template_deployment", Type: "BOOLEAN", Nullable: true},
                        {Name: "enabled_for_disk_encryption", Type: "BOOLEAN", Nullable: true},
                        {Name: "soft_delete_enabled", Type: "BOOLEAN", Nullable: true},
                }...)
                schema.Indexes = append(schema.Indexes, "idx_tenant_id", "idx_sku_name")</span>

        case "Microsoft.ContainerService/managedClusters":<span class="cov0" title="0">
                schema.Columns = append(schema.Columns, []*ColumnDefinition{
                        {Name: "kubernetes_version", Type: "VARCHAR", Nullable: true},
                        {Name: "dns_prefix", Type: "VARCHAR", Nullable: true},
                        {Name: "fqdn", Type: "VARCHAR", Nullable: true},
                        {Name: "node_resource_group", Type: "VARCHAR", Nullable: true},
                        {Name: "agent_pool_count", Type: "INTEGER", Nullable: true},
                        {Name: "network_plugin", Type: "VARCHAR", Nullable: true},
                }...)
                schema.Indexes = append(schema.Indexes, "idx_kubernetes_version", "idx_network_plugin")</span>

        case "Microsoft.DocumentDB/databaseAccounts":<span class="cov0" title="0">
                schema.Columns = append(schema.Columns, []*ColumnDefinition{
                        {Name: "database_account_offer_type", Type: "VARCHAR", Nullable: true},
                        {Name: "consistency_policy", Type: "JSON", Nullable: true},
                        {Name: "locations", Type: "JSON", Nullable: true},
                        {Name: "failover_policies", Type: "JSON", Nullable: true},
                        {Name: "enable_multiple_write_locations", Type: "BOOLEAN", Nullable: true},
                }...)</span>

        case "Microsoft.Insights/components":<span class="cov0" title="0">
                schema.Columns = append(schema.Columns, []*ColumnDefinition{
                        {Name: "application_type", Type: "VARCHAR", Nullable: true},
                        {Name: "application_id", Type: "VARCHAR", Nullable: true},
                        {Name: "instrumentation_key", Type: "VARCHAR", Nullable: true},
                        {Name: "retention_in_days", Type: "INTEGER", Nullable: true},
                        {Name: "sampling_percentage", Type: "FLOAT", Nullable: true},
                }...)
                schema.Indexes = append(schema.Indexes, "idx_application_type")</span>

        default:<span class="cov8" title="1">
                // For unknown resource types, add generic columns
                schema.Columns = append(schema.Columns, []*ColumnDefinition{
                        {Name: "kind", Type: "VARCHAR", Nullable: true},
                        {Name: "sku_name", Type: "VARCHAR", Nullable: true},
                        {Name: "sku_tier", Type: "VARCHAR", Nullable: true},
                        {Name: "managed_by", Type: "VARCHAR", Nullable: true},
                }...)</span>
        }
}

// GenerateSchemaForProvider generates schemas for all resource types in a provider
func (g *AzureSchemaGenerator) GenerateSchemaForProvider(provider *ProviderInfo) []*TableSchema <span class="cov8" title="1">{
        var schemas []*TableSchema

        for _, resourceType := range provider.ResourceTypes </span><span class="cov8" title="1">{
                schema := g.GenerateSchema(resourceType)
                schemas = append(schemas, schema)
        }</span>

        <span class="cov8" title="1">return schemas</span>
}

// GetCachedSchema returns a cached schema if available
func (g *AzureSchemaGenerator) GetCachedSchema(resourceType string) *TableSchema <span class="cov8" title="1">{
        g.mu.RLock()
        defer g.mu.RUnlock()

        tableName := g.generateTableName(resourceType)
        return g.schemaCache[tableName]
}</span>

// ClearCache clears the schema cache
func (g *AzureSchemaGenerator) ClearCache() <span class="cov8" title="1">{
        g.mu.Lock()
        defer g.mu.Unlock()

        g.schemaCache = make(map[string]*TableSchema)
}</span>

// GenerateCreateTableSQL generates CREATE TABLE SQL for a schema
func (g *AzureSchemaGenerator) GenerateCreateTableSQL(schema *TableSchema) string <span class="cov8" title="1">{
        var columns []string
        for _, col := range schema.Columns </span><span class="cov8" title="1">{
                nullable := ""
                if col.Nullable </span><span class="cov8" title="1">{
                        nullable = " NULL"
                }</span> else<span class="cov8" title="1"> {
                        nullable = " NOT NULL"
                }</span>

                <span class="cov8" title="1">pk := ""
                if col.PrimaryKey </span><span class="cov8" title="1">{
                        pk = " PRIMARY KEY"
                }</span>

                <span class="cov8" title="1">columns = append(columns, fmt.Sprintf("  %s %s%s%s", col.Name, col.Type, nullable, pk))</span>
        }

        <span class="cov8" title="1">sql := fmt.Sprintf("CREATE TABLE %s (\n%s\n);", schema.TableName, strings.Join(columns, ",\n"))

        // Add indexes
        for _, index := range schema.Indexes </span><span class="cov8" title="1">{
                sql += fmt.Sprintf("\nCREATE INDEX %s ON %s (%s);", index, schema.TableName, strings.TrimPrefix(index, "idx_"))
        }</span>

        <span class="cov8" title="1">return sql</span>
}

// GenerateInsertSQL generates INSERT SQL for a resource
func (g *AzureSchemaGenerator) GenerateInsertSQL(schema *TableSchema, resourceData map[string]interface{}) string <span class="cov8" title="1">{
        var columns []string
        var placeholders []string

        for _, col := range schema.Columns </span><span class="cov8" title="1">{
                if _, exists := resourceData[col.Name]; exists </span><span class="cov8" title="1">{
                        columns = append(columns, col.Name)
                        placeholders = append(placeholders, "?")
                }</span>
        }

        <span class="cov8" title="1">return fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s);",
                schema.TableName,
                strings.Join(columns, ", "),
                strings.Join(placeholders, ", "))</span>
}

// ValidateSchema validates a schema definition
func (g *AzureSchemaGenerator) ValidateSchema(schema *TableSchema) []string <span class="cov8" title="1">{
        var errors []string

        if schema.TableName == "" </span><span class="cov8" title="1">{
                errors = append(errors, "table name is required")
        }</span>

        <span class="cov8" title="1">if len(schema.Columns) == 0 </span><span class="cov8" title="1">{
                errors = append(errors, "at least one column is required")
        }</span>

        <span class="cov8" title="1">hasPrimaryKey := false
        columnNames := make(map[string]bool)

        for _, col := range schema.Columns </span><span class="cov8" title="1">{
                if col.Name == "" </span><span class="cov8" title="1">{
                        errors = append(errors, "column name is required")
                        continue</span>
                }

                <span class="cov8" title="1">if columnNames[col.Name] </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("duplicate column name: %s", col.Name))
                }</span>
                <span class="cov8" title="1">columnNames[col.Name] = true

                if col.Type == "" </span><span class="cov8" title="1">{
                        errors = append(errors, fmt.Sprintf("column type is required for %s", col.Name))
                }</span>

                <span class="cov8" title="1">if col.PrimaryKey </span><span class="cov8" title="1">{
                        if hasPrimaryKey </span><span class="cov8" title="1">{
                                errors = append(errors, "multiple primary keys not allowed")
                        }</span>
                        <span class="cov8" title="1">hasPrimaryKey = true</span>
                }
        }

        <span class="cov8" title="1">if !hasPrimaryKey </span><span class="cov8" title="1">{
                errors = append(errors, "primary key is required")
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// GetSchemaStatistics returns statistics about cached schemas
func (g *AzureSchemaGenerator) GetSchemaStatistics() map[string]interface{} <span class="cov8" title="1">{
        g.mu.RLock()
        defer g.mu.RUnlock()

        stats := make(map[string]interface{})
        stats["total_schemas"] = len(g.schemaCache)

        columnCounts := make(map[int]int)
        indexCounts := make(map[int]int)

        for _, schema := range g.schemaCache </span><span class="cov8" title="1">{
                columnCount := len(schema.Columns)
                indexCount := len(schema.Indexes)

                columnCounts[columnCount]++
                indexCounts[indexCount]++
        }</span>

        <span class="cov8" title="1">stats["column_distribution"] = columnCounts
        stats["index_distribution"] = indexCounts

        return stats</span>
}

// ExportSchemas exports all cached schemas
func (g *AzureSchemaGenerator) ExportSchemas() map[string]*TableSchema <span class="cov8" title="1">{
        g.mu.RLock()
        defer g.mu.RUnlock()

        exported := make(map[string]*TableSchema)
        for name, schema := range g.schemaCache </span><span class="cov8" title="1">{
                exported[name] = schema
        }</span>

        <span class="cov8" title="1">return exported</span>
}

// ImportSchemas imports schemas into the cache
func (g *AzureSchemaGenerator) ImportSchemas(schemas map[string]*TableSchema) <span class="cov8" title="1">{
        g.mu.Lock()
        defer g.mu.Unlock()

        for name, schema := range schemas </span><span class="cov8" title="1">{
                g.schemaCache[name] = schema
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "sync"
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "testing"
        "time"

        "github.com/Azure/azure-sdk-for-go/sdk/azcore"
        "github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
        "github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/resourcegraph/armresourcegraph"
        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/mock"
)

// Common interfaces and types for testing

// AzureResourceGraphClient interface for testing
type AzureResourceGraphClient interface {
        Query(ctx context.Context, subscriptions []string, query string, options *ResourceGraphQueryOptions) (*ResourceGraphResponse, error)
}

// ResourceGraphQueryOptions for testing
type ResourceGraphQueryOptions struct {
        Top  int32
        Skip int32
}

// ResourceGraphResponse for testing
type ResourceGraphResponse struct {
        TotalRecords int
        Count        int
        Data         []interface{}
        SkipToken    *string
}

// MockCredential for testing
type MockCredential struct{}

func (c *MockCredential) GetToken(ctx context.Context, options policy.TokenRequestOptions) (azcore.AccessToken, error) <span class="cov0" title="0">{
        return azcore.AccessToken{
                Token:     "mock-token",
                ExpiresOn: time.Now().Add(time.Hour),
        }, nil
}</span>

// MockResourceGraphClient for testing
type MockResourceGraphClient struct {
        mock.Mock
}

func (m *MockResourceGraphClient) Resources(ctx context.Context, query armresourcegraph.QueryRequest, options *armresourcegraph.ClientResourcesOptions) (armresourcegraph.ClientResourcesResponse, error) <span class="cov0" title="0">{
        args := m.Called(ctx, query, options)
        return args.Get(0).(armresourcegraph.ClientResourcesResponse), args.Error(1)
}</span>

// MockAzureResourceGraphClient wraps the mock for our interface
type MockAzureResourceGraphClient struct {
        mockClient *MockResourceGraphClient
}

func (m *MockAzureResourceGraphClient) Query(ctx context.Context, subscriptions []string, query string, options *ResourceGraphQueryOptions) (*ResourceGraphResponse, error) <span class="cov0" title="0">{
        // Convert to the expected armresourcegraph types and call mock
        request := armresourcegraph.QueryRequest{
                Query:         to.Ptr(query),
                Subscriptions: make([]*string, len(subscriptions)),
        }
        for i, sub := range subscriptions </span><span class="cov0" title="0">{
                request.Subscriptions[i] = to.Ptr(sub)
        }</span>

        <span class="cov0" title="0">if options != nil </span><span class="cov0" title="0">{
                if options.Top &gt; 0 </span><span class="cov0" title="0">{
                        request.Options = &amp;armresourcegraph.QueryRequestOptions{
                                Top:  &amp;options.Top,
                                Skip: &amp;options.Skip,
                        }
                }</span>
        }

        <span class="cov0" title="0">response, err := m.mockClient.Resources(ctx, request, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert response back to our format
        <span class="cov0" title="0">var data []interface{}
        if response.Data != nil </span><span class="cov0" title="0">{
                if dataSlice, ok := response.Data.([]interface{}); ok </span><span class="cov0" title="0">{
                        data = dataSlice
                }</span>
        }
        
        <span class="cov0" title="0">result := &amp;ResourceGraphResponse{
                TotalRecords: int(*response.TotalRecords),
                Count:        int(*response.Count),
                Data:         data,
                SkipToken:    response.SkipToken,
        }

        return result, nil</span>
}

// DiscoveryResult represents the result of a discovery operation
type DiscoveryResult struct {
        ProviderCount    int
        ResourceCount    int
        SchemaCount      int
        Duration         time.Duration
        Errors          []error
        Timestamp       time.Time
}

// AutoDiscoveryPipeline orchestrates the entire auto-discovery process
type AutoDiscoveryPipeline struct {
        credential      azcore.TokenCredential
        subscriptionID  string
        discovery       *AzureServiceDiscovery
        schemaGenerator *AzureSchemaGenerator
        rgClient        AzureResourceGraphClient
        config          *PipelineConfig
        mu              sync.RWMutex
        running         bool
        results         map[string]*DiscoveryResult
}

// PipelineConfig configures the auto-discovery pipeline
type PipelineConfig struct {
        MaxConcurrency     int
        Timeout           time.Duration
        EnableCaching     bool
        CacheExpiry       time.Duration
        BatchSize         int
        RetryAttempts     int
        RetryDelay        time.Duration
        ProviderFilter    []string
        ResourceTypeFilter []string
        EnableMetrics     bool
        MetricsInterval   time.Duration
}

// TestFixtures provides common test data and utilities
type TestFixtures struct {
        TempDir         string
        TestDataDir     string
        Providers       []*ProviderInfo
        Schemas         []*TableSchema
        MockResponses   map[string]interface{}
}

// NewTestFixtures creates a new test fixtures instance
func NewTestFixtures(t *testing.T) *TestFixtures <span class="cov0" title="0">{
        tempDir := filepath.Join(os.TempDir(), fmt.Sprintf("azure-provider-test-%d", time.Now().UnixNano()))
        err := os.MkdirAll(tempDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create temp directory: %v", err)
        }</span>

        // Get test data directory relative to this file
        <span class="cov0" title="0">_, filename, _, _ := runtime.Caller(0)
        baseDir := filepath.Dir(filename)
        testDataDir := filepath.Join(baseDir, "testdata")

        fixtures := &amp;TestFixtures{
                TempDir:       tempDir,
                TestDataDir:   testDataDir,
                Providers:     createTestProviders(),
                Schemas:       createTestSchemas(),
                MockResponses: createMockResponses(),
        }

        // Create test data directory if it doesn't exist
        os.MkdirAll(testDataDir, 0755)

        return fixtures</span>
}

// Cleanup removes temporary test files
func (f *TestFixtures) Cleanup() <span class="cov0" title="0">{
        os.RemoveAll(f.TempDir)
}</span>

// SaveTestData saves test data to JSON files for reuse
func (f *TestFixtures) SaveTestData() error <span class="cov0" title="0">{
        // Save providers
        providersData, err := json.MarshalIndent(f.Providers, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = os.WriteFile(filepath.Join(f.TestDataDir, "test_providers.json"), providersData, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Save schemas
        <span class="cov0" title="0">schemasData, err := json.MarshalIndent(f.Schemas, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = os.WriteFile(filepath.Join(f.TestDataDir, "test_schemas.json"), schemasData, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Save mock responses
        <span class="cov0" title="0">mockData, err := json.MarshalIndent(f.MockResponses, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = os.WriteFile(filepath.Join(f.TestDataDir, "mock_responses.json"), mockData, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// LoadTestData loads test data from JSON files
func (f *TestFixtures) LoadTestData() error <span class="cov0" title="0">{
        // Load providers
        providersData, err := os.ReadFile(filepath.Join(f.TestDataDir, "test_providers.json"))
        if err == nil </span><span class="cov0" title="0">{
                err = json.Unmarshal(providersData, &amp;f.Providers)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Load schemas
        <span class="cov0" title="0">schemasData, err := os.ReadFile(filepath.Join(f.TestDataDir, "test_schemas.json"))
        if err == nil </span><span class="cov0" title="0">{
                err = json.Unmarshal(schemasData, &amp;f.Schemas)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Load mock responses
        <span class="cov0" title="0">mockData, err := os.ReadFile(filepath.Join(f.TestDataDir, "mock_responses.json"))
        if err == nil </span><span class="cov0" title="0">{
                err = json.Unmarshal(mockData, &amp;f.MockResponses)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Test helper functions

// SetupTestEnvironment prepares the test environment
func SetupTestEnvironment(t *testing.T) *TestEnvironment <span class="cov0" title="0">{
        fixtures := NewTestFixtures(t)
        
        // Setup test cleanup
        t.Cleanup(func() </span><span class="cov0" title="0">{
                fixtures.Cleanup()
        }</span>)

        <span class="cov0" title="0">env := &amp;TestEnvironment{
                Fixtures:        fixtures,
                MockCredential:  &amp;MockCredential{},
                SubscriptionID:  "test-subscription-" + fmt.Sprintf("%d", time.Now().Unix()),
                Context:         context.Background(),
        }

        return env</span>
}

// TestEnvironment provides a complete test environment
type TestEnvironment struct {
        Fixtures       *TestFixtures
        MockCredential *MockCredential
        SubscriptionID string
        Context        context.Context
}

// CreateTestDiscovery creates a discovery instance for testing
func (env *TestEnvironment) CreateTestDiscovery() *AzureServiceDiscovery <span class="cov0" title="0">{
        return NewAzureServiceDiscovery(env.MockCredential, env.SubscriptionID)
}</span>

// CreateTestSchemaGenerator creates a schema generator for testing
func (env *TestEnvironment) CreateTestSchemaGenerator() *AzureSchemaGenerator <span class="cov0" title="0">{
        return NewAzureSchemaGenerator()
}</span>

// CreateTestResourceGraphClient creates a mock Resource Graph client
func (env *TestEnvironment) CreateTestResourceGraphClient() *MockAzureResourceGraphClient <span class="cov0" title="0">{
        mockClient := &amp;MockResourceGraphClient{}
        return &amp;MockAzureResourceGraphClient{mockClient: mockClient}
}</span>

// CreateTestPipeline creates a complete test pipeline
func (env *TestEnvironment) CreateTestPipeline() *AutoDiscoveryPipeline <span class="cov0" title="0">{
        return &amp;AutoDiscoveryPipeline{
                credential:      env.MockCredential,
                subscriptionID:  env.SubscriptionID,
                discovery:       env.CreateTestDiscovery(),
                schemaGenerator: env.CreateTestSchemaGenerator(),
                rgClient:        env.CreateTestResourceGraphClient(),
                config:          DefaultPipelineConfig(),
                results:         make(map[string]*DiscoveryResult),
        }
}</span>

// DefaultPipelineConfig returns default configuration for testing
func DefaultPipelineConfig() *PipelineConfig <span class="cov0" title="0">{
        return &amp;PipelineConfig{
                MaxConcurrency:  10,
                Timeout:         5 * time.Minute,
                EnableCaching:   true,
                CacheExpiry:     30 * time.Minute,
                BatchSize:       100,
                RetryAttempts:   3,
                RetryDelay:      1 * time.Second,
                EnableMetrics:   true,
                MetricsInterval: 30 * time.Second,
        }
}</span>

// Test data creation functions

func createTestProviders() []*ProviderInfo <span class="cov0" title="0">{
        return []*ProviderInfo{
                {
                        Namespace:         "Microsoft.Compute",
                        RegistrationState: "Registered",
                        ResourceTypes: []ResourceTypeInfo{
                                {
                                        ResourceType: "virtualMachines",
                                        APIVersions:  []string{"2023-03-01", "2022-11-01", "2022-08-01"},
                                        Locations:    []string{"East US", "West US", "Central US", "North Europe", "West Europe"},
                                        Capabilities: []string{"SupportsAvailabilityZones", "SupportsAcceleratedNetworking"},
                                        Properties: map[string]interface{}{
                                                "supports_list": true,
                                                "supports_get":  true,
                                                "supports_tags": true,
                                        },
                                },
                                {
                                        ResourceType: "disks",
                                        APIVersions:  []string{"2023-01-02", "2022-07-02", "2022-03-02"},
                                        Locations:    []string{"East US", "West US", "Central US", "North Europe", "West Europe"},
                                        Properties: map[string]interface{}{
                                                "supports_list": true,
                                                "supports_get":  true,
                                                "supports_tags": true,
                                        },
                                },
                                {
                                        ResourceType: "availabilitySets",
                                        APIVersions:  []string{"2023-03-01", "2022-11-01"},
                                        Locations:    []string{"East US", "West US", "Central US"},
                                        Properties: map[string]interface{}{
                                                "supports_list": true,
                                                "supports_get":  true,
                                                "supports_tags": true,
                                        },
                                },
                        },
                },
                {
                        Namespace:         "Microsoft.Storage",
                        RegistrationState: "Registered",
                        ResourceTypes: []ResourceTypeInfo{
                                {
                                        ResourceType: "storageAccounts",
                                        APIVersions:  []string{"2023-01-01", "2022-09-01", "2022-05-01"},
                                        Locations:    []string{"East US", "West US", "Central US", "North Europe", "West Europe", "Southeast Asia"},
                                        Properties: map[string]interface{}{
                                                "supports_list": true,
                                                "supports_get":  true,
                                                "supports_tags": true,
                                        },
                                },
                                {
                                        ResourceType: "storageAccounts/blobServices",
                                        APIVersions:  []string{"2023-01-01", "2022-09-01"},
                                        Locations:    []string{"East US", "West US", "Central US", "North Europe", "West Europe"},
                                        Properties: map[string]interface{}{
                                                "supports_list": true,
                                                "supports_get":  true,
                                                "supports_tags": false,
                                        },
                                },
                        },
                },
                {
                        Namespace:         "Microsoft.Network",
                        RegistrationState: "Registered",
                        ResourceTypes: []ResourceTypeInfo{
                                {
                                        ResourceType: "virtualNetworks",
                                        APIVersions:  []string{"2023-02-01", "2022-11-01", "2022-07-01"},
                                        Locations:    []string{"East US", "West US", "Central US", "North Europe", "West Europe"},
                                        Properties: map[string]interface{}{
                                                "supports_list": true,
                                                "supports_get":  true,
                                                "supports_tags": true,
                                        },
                                },
                                {
                                        ResourceType: "networkSecurityGroups",
                                        APIVersions:  []string{"2023-02-01", "2022-11-01"},
                                        Locations:    []string{"East US", "West US", "Central US", "North Europe", "West Europe"},
                                        Properties: map[string]interface{}{
                                                "supports_list": true,
                                                "supports_get":  true,
                                                "supports_tags": true,
                                        },
                                },
                                {
                                        ResourceType: "publicIPAddresses",
                                        APIVersions:  []string{"2023-02-01", "2022-11-01"},
                                        Locations:    []string{"East US", "West US", "Central US", "North Europe", "West Europe"},
                                        Properties: map[string]interface{}{
                                                "supports_list": true,
                                                "supports_get":  true,
                                                "supports_tags": true,
                                        },
                                },
                        },
                },
                {
                        Namespace:         "Microsoft.Web",
                        RegistrationState: "Registered",
                        ResourceTypes: []ResourceTypeInfo{
                                {
                                        ResourceType: "sites",
                                        APIVersions:  []string{"2022-09-01", "2022-03-01"},
                                        Locations:    []string{"East US", "West US", "Central US", "North Europe", "West Europe"},
                                        Properties: map[string]interface{}{
                                                "supports_list": true,
                                                "supports_get":  true,
                                                "supports_tags": true,
                                        },
                                },
                                {
                                        ResourceType: "serverfarms",
                                        APIVersions:  []string{"2022-09-01", "2022-03-01"},
                                        Locations:    []string{"East US", "West US", "Central US", "North Europe", "West Europe"},
                                        Properties: map[string]interface{}{
                                                "supports_list": true,
                                                "supports_get":  true,
                                                "supports_tags": true,
                                        },
                                },
                        },
                },
                {
                        Namespace:         "Microsoft.Sql",
                        RegistrationState: "Registered",
                        ResourceTypes: []ResourceTypeInfo{
                                {
                                        ResourceType: "servers",
                                        APIVersions:  []string{"2022-11-01-preview", "2022-05-01-preview"},
                                        Locations:    []string{"East US", "West US", "Central US", "North Europe", "West Europe"},
                                        Properties: map[string]interface{}{
                                                "supports_list": true,
                                                "supports_get":  true,
                                                "supports_tags": true,
                                        },
                                },
                                {
                                        ResourceType: "servers/databases",
                                        APIVersions:  []string{"2022-11-01-preview", "2022-05-01-preview"},
                                        Locations:    []string{"East US", "West US", "Central US", "North Europe", "West Europe"},
                                        Properties: map[string]interface{}{
                                                "supports_list": true,
                                                "supports_get":  true,
                                                "supports_tags": true,
                                        },
                                },
                        },
                },
                {
                        Namespace:         "Microsoft.NotRegistered",
                        RegistrationState: "NotRegistered",
                        ResourceTypes: []ResourceTypeInfo{
                                {
                                        ResourceType: "testResources",
                                        APIVersions:  []string{"2023-01-01"},
                                        Locations:    []string{"East US"},
                                        Properties: map[string]interface{}{
                                                "supports_list": true,
                                                "supports_get":  true,
                                                "supports_tags": true,
                                        },
                                },
                        },
                },
        }
}</span>

func createTestSchemas() []*TableSchema <span class="cov0" title="0">{
        return []*TableSchema{
                {
                        TableName: "azure_compute_virtualmachines",
                        Columns: []*ColumnDefinition{
                                {Name: "id", Type: "VARCHAR", PrimaryKey: true, Nullable: false},
                                {Name: "name", Type: "VARCHAR", Nullable: false},
                                {Name: "type", Type: "VARCHAR", Nullable: false},
                                {Name: "location", Type: "VARCHAR", Nullable: false},
                                {Name: "resource_group", Type: "VARCHAR", Nullable: false},
                                {Name: "subscription_id", Type: "VARCHAR", Nullable: false},
                                {Name: "vm_size", Type: "VARCHAR", Nullable: true},
                                {Name: "os_type", Type: "VARCHAR", Nullable: true},
                                {Name: "power_state", Type: "VARCHAR", Nullable: true},
                                {Name: "properties", Type: "JSON", Nullable: true},
                                {Name: "tags", Type: "JSON", Nullable: true},
                                {Name: "discovered_at", Type: "TIMESTAMP", Nullable: false},
                        },
                        Indexes: []string{"idx_name", "idx_location", "idx_vm_size", "idx_os_type"},
                },
                {
                        TableName: "azure_storage_storageaccounts",
                        Columns: []*ColumnDefinition{
                                {Name: "id", Type: "VARCHAR", PrimaryKey: true, Nullable: false},
                                {Name: "name", Type: "VARCHAR", Nullable: false},
                                {Name: "type", Type: "VARCHAR", Nullable: false},
                                {Name: "location", Type: "VARCHAR", Nullable: false},
                                {Name: "resource_group", Type: "VARCHAR", Nullable: false},
                                {Name: "subscription_id", Type: "VARCHAR", Nullable: false},
                                {Name: "account_type", Type: "VARCHAR", Nullable: true},
                                {Name: "access_tier", Type: "VARCHAR", Nullable: true},
                                {Name: "encryption_enabled", Type: "BOOLEAN", Nullable: true},
                                {Name: "properties", Type: "JSON", Nullable: true},
                                {Name: "tags", Type: "JSON", Nullable: true},
                                {Name: "discovered_at", Type: "TIMESTAMP", Nullable: false},
                        },
                        Indexes: []string{"idx_name", "idx_location", "idx_account_type"},
                },
        }
}</span>

func createMockResponses() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "vm_list_response": []interface{}{
                        map[string]interface{}{
                                "id":       "/subscriptions/test-sub/resourceGroups/test-rg/providers/Microsoft.Compute/virtualMachines/test-vm-1",
                                "name":     "test-vm-1",
                                "type":     "Microsoft.Compute/virtualMachines",
                                "location": "eastus",
                                "properties": map[string]interface{}{
                                        "hardwareProfile": map[string]interface{}{
                                                "vmSize": "Standard_D2s_v3",
                                        },
                                        "osProfile": map[string]interface{}{
                                                "computerName": "test-vm-1",
                                        },
                                        "provisioningState": "Succeeded",
                                },
                                "tags": map[string]interface{}{
                                        "environment": "test",
                                        "project":     "azure-provider",
                                },
                        },
                        map[string]interface{}{
                                "id":       "/subscriptions/test-sub/resourceGroups/test-rg/providers/Microsoft.Compute/virtualMachines/test-vm-2",
                                "name":     "test-vm-2",
                                "type":     "Microsoft.Compute/virtualMachines",
                                "location": "westus",
                                "properties": map[string]interface{}{
                                        "hardwareProfile": map[string]interface{}{
                                                "vmSize": "Standard_B2s",
                                        },
                                        "osProfile": map[string]interface{}{
                                                "computerName": "test-vm-2",
                                        },
                                        "provisioningState": "Succeeded",
                                },
                                "tags": map[string]interface{}{
                                        "environment": "production",
                                        "project":     "web-app",
                                },
                        },
                },
                "storage_list_response": []interface{}{
                        map[string]interface{}{
                                "id":       "/subscriptions/test-sub/resourceGroups/test-rg/providers/Microsoft.Storage/storageAccounts/teststorage001",
                                "name":     "teststorage001",
                                "type":     "Microsoft.Storage/storageAccounts",
                                "location": "eastus",
                                "properties": map[string]interface{}{
                                        "accountType":              "Standard_LRS",
                                        "supportsHttpsTrafficOnly": true,
                                        "primaryEndpoints": map[string]interface{}{
                                                "blob": "https://teststorage001.blob.core.windows.net/",
                                        },
                                },
                                "tags": map[string]interface{}{
                                        "environment": "test",
                                },
                        },
                },
        }
}</span>

// Mock setup helpers

// SetupMockResourceGraphClient configures a mock Resource Graph client with realistic responses
func SetupMockResourceGraphClient(mockClient *MockResourceGraphClient, fixtures *TestFixtures) <span class="cov0" title="0">{
        // Setup default responses for common queries
        vmResponse := armresourcegraph.ClientResourcesResponse{
                QueryResponse: armresourcegraph.QueryResponse{
                        TotalRecords: to.Ptr(int64(2)),
                        Count:        to.Ptr(int64(2)),
                        Data:         fixtures.MockResponses["vm_list_response"],
                },
        }

        storageResponse := armresourcegraph.ClientResourcesResponse{
                QueryResponse: armresourcegraph.QueryResponse{
                        TotalRecords: to.Ptr(int64(1)),
                        Count:        to.Ptr(int64(1)),
                        Data:         fixtures.MockResponses["storage_list_response"],
                },
        }

        emptyResponse := armresourcegraph.ClientResourcesResponse{
                QueryResponse: armresourcegraph.QueryResponse{
                        TotalRecords: to.Ptr(int64(0)),
                        Count:        to.Ptr(int64(0)),
                        Data:         []interface{}{},
                },
        }

        // Mock VM queries
        mockClient.On("Resources", mock.Anything, mock.MatchedBy(func(req armresourcegraph.QueryRequest) bool </span><span class="cov0" title="0">{
                return req.Query != nil &amp;&amp; strings.Contains(*req.Query, "Microsoft.Compute/virtualMachines")
        }</span>), mock.Anything).Return(vmResponse, nil)

        // Mock Storage queries
        <span class="cov0" title="0">mockClient.On("Resources", mock.Anything, mock.MatchedBy(func(req armresourcegraph.QueryRequest) bool </span><span class="cov0" title="0">{
                return req.Query != nil &amp;&amp; strings.Contains(*req.Query, "Microsoft.Storage/storageAccounts")
        }</span>), mock.Anything).Return(storageResponse, nil)

        // Mock empty responses for unknown resource types
        <span class="cov0" title="0">mockClient.On("Resources", mock.Anything, mock.MatchedBy(func(req armresourcegraph.QueryRequest) bool </span><span class="cov0" title="0">{
                return req.Query != nil &amp;&amp; strings.Contains(*req.Query, "Microsoft.Unknown")
        }</span>), mock.Anything).Return(emptyResponse, nil)

        // Default catch-all mock
        <span class="cov0" title="0">mockClient.On("Resources", mock.Anything, mock.Anything, mock.Anything).Return(emptyResponse, nil)</span>
}

// Performance test helpers

// BenchmarkTimer helps measure execution time in benchmarks
type BenchmarkTimer struct {
        start     time.Time
        operation string
}

// NewBenchmarkTimer creates a new benchmark timer
func NewBenchmarkTimer(operation string) *BenchmarkTimer <span class="cov0" title="0">{
        return &amp;BenchmarkTimer{
                start:     time.Now(),
                operation: operation,
        }
}</span>

// Stop stops the timer and returns the duration
func (bt *BenchmarkTimer) Stop() time.Duration <span class="cov0" title="0">{
        return time.Since(bt.start)
}</span>

// MemoryProfiler helps track memory usage in tests
type MemoryProfiler struct {
        initial runtime.MemStats
        final   runtime.MemStats
}

// NewMemoryProfiler creates a new memory profiler
func NewMemoryProfiler() *MemoryProfiler <span class="cov0" title="0">{
        mp := &amp;MemoryProfiler{}
        runtime.GC() // Force garbage collection
        runtime.ReadMemStats(&amp;mp.initial)
        return mp
}</span>

// Stop captures final memory statistics
func (mp *MemoryProfiler) Stop() <span class="cov0" title="0">{
        runtime.GC() // Force garbage collection
        runtime.ReadMemStats(&amp;mp.final)
}</span>

// AllocatedBytes returns the number of bytes allocated during the profiling period
func (mp *MemoryProfiler) AllocatedBytes() uint64 <span class="cov0" title="0">{
        return mp.final.TotalAlloc - mp.initial.TotalAlloc
}</span>

// HeapIncrease returns the increase in heap size
func (mp *MemoryProfiler) HeapIncrease() uint64 <span class="cov0" title="0">{
        return mp.final.HeapInuse - mp.initial.HeapInuse
}</span>

// Test assertion helpers

// AssertSchemaValid validates that a schema meets basic requirements
func AssertSchemaValid(t *testing.T, schema *TableSchema, resourceType string) <span class="cov0" title="0">{
        t.Helper()

        // Basic validations
        assert.NotEmpty(t, schema.TableName, "Schema should have a table name")
        assert.NotEmpty(t, schema.Columns, "Schema should have columns")

        // Check for required columns
        requiredColumns := []string{"id", "name", "type", "location"}
        columnNames := make(map[string]bool)
        
        for _, col := range schema.Columns </span><span class="cov0" title="0">{
                columnNames[col.Name] = true
        }</span>

        <span class="cov0" title="0">for _, required := range requiredColumns </span><span class="cov0" title="0">{
                assert.True(t, columnNames[required], 
                        "Schema for %s should have required column: %s", resourceType, required)
        }</span>

        // Check primary key
        <span class="cov0" title="0">hasPrimaryKey := false
        for _, col := range schema.Columns </span><span class="cov0" title="0">{
                if col.PrimaryKey </span><span class="cov0" title="0">{
                        hasPrimaryKey = true
                        break</span>
                }
        }
        <span class="cov0" title="0">assert.True(t, hasPrimaryKey, "Schema should have a primary key")</span>
}

// AssertProviderValid validates that a provider meets basic requirements
func AssertProviderValid(t *testing.T, provider *ProviderInfo) <span class="cov0" title="0">{
        t.Helper()

        assert.NotEmpty(t, provider.Namespace, "Provider should have a namespace")
        assert.NotEmpty(t, provider.RegistrationState, "Provider should have a registration state")
        assert.NotEmpty(t, provider.ResourceTypes, "Provider should have resource types")

        for _, rt := range provider.ResourceTypes </span><span class="cov0" title="0">{
                assert.NotEmpty(t, rt.ResourceType, "Resource type should have a name")
                assert.NotEmpty(t, rt.APIVersions, "Resource type should have API versions")
        }</span>
}

// Test data validation

// ValidateTestData ensures test data is consistent and realistic
func ValidateTestData(t *testing.T, fixtures *TestFixtures) <span class="cov0" title="0">{
        t.Helper()

        // Validate providers
        assert.NotEmpty(t, fixtures.Providers, "Test fixtures should have providers")
        for _, provider := range fixtures.Providers </span><span class="cov0" title="0">{
                AssertProviderValid(t, provider)
        }</span>

        // Validate schemas
        <span class="cov0" title="0">assert.NotEmpty(t, fixtures.Schemas, "Test fixtures should have schemas")
        for _, schema := range fixtures.Schemas </span><span class="cov0" title="0">{
                generator := NewAzureSchemaGenerator()
                errors := generator.ValidateSchema(schema)
                assert.Empty(t, errors, "Test schema should be valid: %v", errors)
        }</span>

        // Validate mock responses
        <span class="cov0" title="0">assert.NotEmpty(t, fixtures.MockResponses, "Test fixtures should have mock responses")
        
        // Validate VM response structure
        if vmResponse, exists := fixtures.MockResponses["vm_list_response"]; exists </span><span class="cov0" title="0">{
                vmList, ok := vmResponse.([]interface{})
                assert.True(t, ok, "VM response should be a list")
                assert.NotEmpty(t, vmList, "VM response should not be empty")
                
                for _, vm := range vmList </span><span class="cov0" title="0">{
                        vmData, ok := vm.(map[string]interface{})
                        assert.True(t, ok, "VM data should be a map")
                        assert.Contains(t, vmData, "id", "VM should have ID")
                        assert.Contains(t, vmData, "name", "VM should have name")
                        assert.Contains(t, vmData, "type", "VM should have type")
                }</span>
        }
}

// Context helpers

// CreateTestContext creates a context with appropriate timeout for tests
func CreateTestContext(duration time.Duration) (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        return context.WithTimeout(context.Background(), duration)
}</span>

// CreateTestContextWithCancel creates a cancellable context for tests
func CreateTestContextWithCancel() (context.Context, context.CancelFunc) <span class="cov0" title="0">{
        return context.WithCancel(context.Background())
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
