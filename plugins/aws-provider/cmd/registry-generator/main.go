package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"strings"
	"text/template"
	"time"
)

var (
	servicesFile = flag.String("services", "generated/services.json", "Path to services.json from analyzer")
	outputFile   = flag.String("output", "generated/scanner_registry.go", "Output file for generated registry")
	packageName  = flag.String("package", "generated", "Package name for generated code")
	verbose      = flag.Bool("verbose", false, "Enable verbose logging")
)

const registryTemplate = `// Code generated by registry-generator. DO NOT EDIT.
// Generated at: {{ .GeneratedAt }}

package {{ .Package }}

import (
	"context"
	"fmt"
	
	"github.com/aws/aws-sdk-go-v2/aws"
	pb "github.com/jlgore/corkscrew/internal/proto"
	"github.com/jlgore/corkscrew/plugins/aws-provider/runtime"
	"github.com/jlgore/corkscrew/plugins/aws-provider/generated/scanners"
	"golang.org/x/time/rate"
)

// RegisterAllScanners registers all generated scanners with the registry
func RegisterAllScanners(registry *runtime.ScannerRegistry) error {
	var registrationErrors []error

	{{ range .Services }}
	// Register {{ .Name }} scanner
	if err := register{{ .CapitalizedName }}Scanner(registry); err != nil {
		registrationErrors = append(registrationErrors, fmt.Errorf("failed to register {{ .Name }} scanner: %w", err))
	}
	{{ end }}

	if len(registrationErrors) > 0 {
		return fmt.Errorf("scanner registration failed with %d errors: %v", len(registrationErrors), registrationErrors)
	}

	return nil
}

{{ range .Services }}
// register{{ .CapitalizedName }}Scanner registers the {{ .Name }} service scanner
func register{{ .CapitalizedName }}Scanner(registry *runtime.ScannerRegistry) error {
	scanner := &scanners.{{ .CapitalizedName }}Scanner{}
	
	metadata := &runtime.ScannerMetadata{
		ServiceName:          "{{ .Name }}",
		ResourceTypes:        []string{ {{ range .ResourceTypes }}"{{ .Name }}", {{ end }} },
		SupportsPagination:   {{ .SupportsPagination }},
		SupportsParallelScan: true,
		RequiredPermissions:  []string{ {{ range .RequiredPermissions }}"{{ . }}", {{ end }} },
		RateLimit:           rate.Limit({{ .RateLimit }}),
		BurstLimit:          {{ .BurstLimit }},
	}

	return registry.Register(scanner, metadata)
}
{{ end }}

// ServiceMetadata contains metadata for all services
var ServiceMetadata = map[string]*runtime.ScannerMetadata{
	{{ range .Services }}
	"{{ .Name }}": {
		ServiceName:          "{{ .Name }}",
		ResourceTypes:        []string{ {{ range .ResourceTypes }}"{{ .Name }}", {{ end }} },
		SupportsPagination:   {{ .SupportsPagination }},
		SupportsParallelScan: true,
		RequiredPermissions:  []string{ {{ range .RequiredPermissions }}"{{ . }}", {{ end }} },
		RateLimit:           rate.Limit({{ .RateLimit }}),
		BurstLimit:          {{ .BurstLimit }},
	},
	{{ end }}
}

// GetServiceScanner returns a scanner for the specified service
func GetServiceScanner(serviceName string) (runtime.ServiceScanner, error) {
	switch serviceName {
	{{ range .Services }}
	case "{{ .Name }}":
		return &scanners.{{ .CapitalizedName }}Scanner{}, nil
	{{ end }}
	default:
		return nil, fmt.Errorf("unknown service: %s", serviceName)
	}
}

// ListAvailableServices returns all available service names
func ListAvailableServices() []string {
	return []string{
		{{ range .Services }}"{{ .Name }}",
		{{ end }}
	}
}

// GetServiceResourceTypes returns resource types for a service
func GetServiceResourceTypes(serviceName string) ([]string, error) {
	metadata, exists := ServiceMetadata[serviceName]
	if !exists {
		return nil, fmt.Errorf("service not found: %s", serviceName)
	}
	return metadata.ResourceTypes, nil
}
`

type RegistryData struct {
	GeneratedAt time.Time
	Package     string
	Services    []ServiceData
}

type ServiceData struct {
	Name                string
	CapitalizedName     string
	ResourceTypes       []ResourceTypeData
	SupportsPagination  bool
	RequiredPermissions []string
	RateLimit           int
	BurstLimit          int
}

type ResourceTypeData struct {
	Name string
}

func main() {
	flag.Parse()

	// Load services
	services, err := loadServices(*servicesFile)
	if err != nil {
		log.Fatalf("Failed to load services: %v", err)
	}

	// Generate registry code
	code, err := generateRegistry(services, *packageName)
	if err != nil {
		log.Fatalf("Failed to generate registry: %v", err)
	}

	// Format the generated code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		log.Printf("Warning: Failed to format generated code: %v", err)
		formatted = []byte(code)
	}

	// Write output
	if err := ioutil.WriteFile(*outputFile, formatted, 0644); err != nil {
		log.Fatalf("Failed to write output file: %v", err)
	}

	if *verbose {
		log.Printf("Generated scanner registry with %d services", len(services.Services))
		log.Printf("Output written to: %s", *outputFile)
	}
}

func loadServices(path string) (*AnalysisResult, error) {
	data, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var result AnalysisResult
	if err := json.Unmarshal(data, &result); err != nil {
		return nil, err
	}

	return &result, nil
}

func generateRegistry(services *AnalysisResult, pkg string) (string, error) {
	data := RegistryData{
		GeneratedAt: time.Now(),
		Package:     pkg,
		Services:    make([]ServiceData, 0),
	}

	// Convert services to template data
	for _, service := range services.Services {
		serviceData := ServiceData{
			Name:                service.Name,
			CapitalizedName:     capitalizeServiceName(service.Name),
			ResourceTypes:       make([]ResourceTypeData, 0),
			SupportsPagination:  hasPaginatedOperations(service),
			RequiredPermissions: generateRequiredPermissions(service),
			RateLimit:           calculateRateLimit(service),
			BurstLimit:          calculateBurstLimit(service),
		}

		// Add resource types
		for _, rt := range service.ResourceTypes {
			serviceData.ResourceTypes = append(serviceData.ResourceTypes, ResourceTypeData{
				Name: rt.Name,
			})
		}

		data.Services = append(data.Services, serviceData)
	}

	// Execute template
	tmpl, err := template.New("registry").Parse(registryTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}

func capitalizeServiceName(name string) string {
	// Handle special cases
	specialCases := map[string]string{
		"s3":       "S3",
		"ec2":      "EC2",
		"iam":      "IAM",
		"rds":      "RDS",
		"sqs":      "SQS",
		"sns":      "SNS",
		"ecs":      "ECS",
		"eks":      "EKS",
		"dynamodb": "DynamoDB",
		"lambda":   "Lambda",
	}

	if special, ok := specialCases[strings.ToLower(name)]; ok {
		return special
	}

	// Default capitalization
	return strings.Title(name)
}

func hasPaginatedOperations(service ServiceInfo) bool {
	for _, op := range service.Operations {
		if op.IsPaginated {
			return true
		}
	}
	return false
}

func generateRequiredPermissions(service ServiceInfo) []string {
	permissions := make(map[string]bool)
	
	// Generate permissions based on operations
	for _, op := range service.Operations {
		if strings.HasPrefix(op.Name, "List") || strings.HasPrefix(op.Name, "Describe") || strings.HasPrefix(op.Name, "Get") {
			permission := fmt.Sprintf("%s:%s", service.Name, op.Name)
			permissions[permission] = true
		}
	}

	// Add wildcard describe permission as fallback
	permissions[fmt.Sprintf("%s:Describe*", service.Name)] = true
	permissions[fmt.Sprintf("%s:List*", service.Name)] = true
	permissions[fmt.Sprintf("%s:Get*", service.Name)] = true

	// Convert to slice
	result := make([]string, 0, len(permissions))
	for perm := range permissions {
		result = append(result, perm)
	}

	return result
}

func calculateRateLimit(service ServiceInfo) int {
	// Service-specific rate limits based on AWS API limits
	rateLimits := map[string]int{
		"ec2":      20,
		"s3":       100,
		"lambda":   50,
		"rds":      20,
		"dynamodb": 25,
		"iam":      10,
		"sqs":      30,
		"sns":      30,
		"ecs":      20,
		"eks":      20,
	}

	if limit, ok := rateLimits[strings.ToLower(service.Name)]; ok {
		return limit
	}

	// Default rate limit
	return 10
}

func calculateBurstLimit(service ServiceInfo) int {
	// Burst limit is typically 2x the rate limit
	return calculateRateLimit(service) * 2
}

// Types from analyzer (simplified for this generator)
type AnalysisResult struct {
	Services []ServiceInfo `json:"services"`
}

type ServiceInfo struct {
	Name          string            `json:"name"`
	Operations    []OperationInfo   `json:"operations"`
	ResourceTypes []ResourceTypeInfo `json:"resource_types"`
}

type OperationInfo struct {
	Name        string `json:"name"`
	IsPaginated bool   `json:"is_paginated"`
}

type ResourceTypeInfo struct {
	Name string `json:"name"`
}