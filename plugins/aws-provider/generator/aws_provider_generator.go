package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// AWSProviderGenerator generates sophisticated AWS scanner plugins using the new plugin architecture
type AWSProviderGenerator struct {
	pluginGenerator *PluginGenerator
	outputDir       string
	debug           bool
}

// NewAWSProviderGenerator creates a new sophisticated AWS provider generator
func NewAWSProviderGenerator(outputDir string) *AWSProviderGenerator {
	return &AWSProviderGenerator{
		pluginGenerator: NewPluginGenerator(),
		outputDir:       outputDir,
		debug:           false,
	}
}

// SetDebug enables or disables debug logging
func (g *AWSProviderGenerator) SetDebug(debug bool) {
	g.debug = debug
}

// GenerateServiceScanners generates sophisticated scanner plugins for multiple AWS services
func (g *AWSProviderGenerator) GenerateServiceScanners(services []*AWSServiceInfo) (*GenerationResult, error) {
	if g.debug {
		fmt.Printf("üîß Generating sophisticated scanner plugins for %d AWS services\n", len(services))
	}

	result := &GenerationResult{
		GeneratedPlugins: make(map[string]*GeneratedPlugin),
		Errors:           make([]string, 0),
		TotalServices:    len(services),
	}

	// Ensure output directory exists
	if err := os.MkdirAll(g.outputDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create output directory %s: %w", g.outputDir, err)
	}

	// Generate individual scanner plugins for each service
	for _, service := range services {
		if g.debug {
			fmt.Printf("üîç Generating sophisticated scanner plugin for service: %s\n", service.Name)
		}

		plugin, err := g.generateServicePlugin(service)
		if err != nil {
			errorMsg := fmt.Sprintf("failed to generate plugin for %s: %v", service.Name, err)
			result.Errors = append(result.Errors, errorMsg)
			if g.debug {
				fmt.Printf("‚ùå %s\n", errorMsg)
			}
			continue
		}

		result.GeneratedPlugins[service.Name] = plugin
		result.SuccessfulServices++

		if g.debug {
			fmt.Printf("‚úÖ Generated sophisticated scanner plugin for %s: %s\n", service.Name, plugin.FilePath)
		}
	}

	// Generate build script for all plugins
	buildScript, err := g.generateBuildScript(services)
	if err != nil {
		result.Errors = append(result.Errors, fmt.Sprintf("failed to generate build script: %v", err))
	} else {
		result.BuildScriptPath = buildScript
		if g.debug {
			fmt.Printf("‚úÖ Generated build script: %s\n", buildScript)
		}
	}

	// Generate plugin manager configuration
	configFile, err := g.generatePluginConfig(services)
	if err != nil {
		result.Errors = append(result.Errors, fmt.Sprintf("failed to generate plugin config: %v", err))
	} else {
		result.ConfigPath = configFile
		if g.debug {
			fmt.Printf("‚úÖ Generated plugin configuration: %s\n", configFile)
		}
	}

	if g.debug {
		fmt.Printf("üéâ Generation complete: %d/%d services successful\n", result.SuccessfulServices, result.TotalServices)
	}

	return result, nil
}

// generateServicePlugin generates a sophisticated scanner plugin for a single service
func (g *AWSProviderGenerator) generateServicePlugin(service *AWSServiceInfo) (*GeneratedPlugin, error) {
	// Generate the plugin code using the sophisticated plugin generator
	code, err := g.pluginGenerator.GeneratePlugin(service)
	if err != nil {
		return nil, fmt.Errorf("failed to generate plugin code: %w", err)
	}

	// Write the plugin to a file
	filename := fmt.Sprintf("corkscrew-%s.go", service.Name)
	filePath := filepath.Join(g.outputDir, filename)

	if err := os.WriteFile(filePath, []byte(code), 0644); err != nil {
		return nil, fmt.Errorf("failed to write plugin file: %w", err)
	}

	plugin := &GeneratedPlugin{
		ServiceName:   service.Name,
		FilePath:      filePath,
		BinaryName:    fmt.Sprintf("corkscrew-%s", service.Name),
		ResourceTypes: extractResourceTypes(service),
		Operations:    extractOperations(service),
		Capabilities:  []string{"hierarchical_discovery", "two_phase_scan", "relationships", "streaming"},
		RequiredPerms: extractRequiredPermissions(service),
		GeneratedAt:   fmt.Sprintf("%d", len(code)), // Use code length as a simple metric
	}

	return plugin, nil
}

// generateBuildScript creates a build script to compile all scanner plugins
func (g *AWSProviderGenerator) generateBuildScript(services []*AWSServiceInfo) (string, error) {
	var script strings.Builder

	script.WriteString("#!/bin/bash\n")
	script.WriteString("# Sophisticated AWS Scanner Plugin Build Script\n")
	script.WriteString("# Generated by Corkscrew AWS Provider Generator\n\n")
	script.WriteString("set -e\n\n")
	script.WriteString("echo \"üîß Building sophisticated AWS scanner plugins...\"\n\n")

	script.WriteString("# Build directory\n")
	script.WriteString("BUILD_DIR=\"./build/plugins\"\n")
	script.WriteString("mkdir -p \"$BUILD_DIR\"\n\n")

	script.WriteString("# Build each scanner plugin\n")
	for _, service := range services {
		script.WriteString(fmt.Sprintf("echo \"üîç Building %s scanner plugin...\"\n", service.Name))
		script.WriteString(fmt.Sprintf("go build -o \"$BUILD_DIR/corkscrew-%s\" \"./corkscrew-%s.go\"\n",
			service.Name, service.Name))
		script.WriteString(fmt.Sprintf("echo \"‚úÖ Built corkscrew-%s\"\n\n", service.Name))
	}

	script.WriteString("echo \"üéâ All sophisticated scanner plugins built successfully!\"\n")
	script.WriteString("echo \"üìÅ Plugins available in: $BUILD_DIR\"\n")
	script.WriteString("ls -la \"$BUILD_DIR\"\n")

	scriptPath := filepath.Join(g.outputDir, "build-plugins.sh")
	if err := os.WriteFile(scriptPath, []byte(script.String()), 0755); err != nil {
		return "", fmt.Errorf("failed to write build script: %w", err)
	}

	return scriptPath, nil
}

// generatePluginConfig creates a configuration file for the plugin manager
func (g *AWSProviderGenerator) generatePluginConfig(services []*AWSServiceInfo) (string, error) {
	var config strings.Builder

	config.WriteString("# Sophisticated AWS Scanner Plugin Configuration\n")
	config.WriteString("# Generated by Corkscrew AWS Provider Generator\n\n")

	config.WriteString("[plugin_manager]\n")
	config.WriteString("plugin_dir = \"./build/plugins\"\n")
	config.WriteString("debug = true\n")
	config.WriteString("timeout = \"30s\"\n\n")

	config.WriteString("[aws_services]\n")
	for _, service := range services {
		config.WriteString(fmt.Sprintf("# %s service configuration\n", strings.Title(service.Name)))
		config.WriteString(fmt.Sprintf("[aws_services.%s]\n", service.Name))
		config.WriteString(fmt.Sprintf("plugin_name = \"corkscrew-%s\"\n", service.Name))
		config.WriteString(fmt.Sprintf("resource_types = %s\n", formatResourceTypes(service)))
		config.WriteString(fmt.Sprintf("capabilities = [\"hierarchical_discovery\", \"two_phase_scan\", \"relationships\", \"streaming\"]\n"))
		config.WriteString(fmt.Sprintf("required_permissions = %s\n", formatRequiredPermissions(service)))
		config.WriteString("\n")
	}

	configPath := filepath.Join(g.outputDir, "plugins.toml")
	if err := os.WriteFile(configPath, []byte(config.String()), 0644); err != nil {
		return "", fmt.Errorf("failed to write plugin config: %w", err)
	}

	return configPath, nil
}

// GenerateAWSProvider generates a lightweight AWS provider that coordinates sophisticated scanner plugins
func (g *AWSProviderGenerator) GenerateAWSProvider(services []*AWSServiceInfo) (string, error) {
	var serviceNames strings.Builder
	var pluginLoaders strings.Builder

	for _, service := range services {
		serviceNames.WriteString(fmt.Sprintf("\t\t\t\"%s\",\n", service.Name))
		pluginLoaders.WriteString(fmt.Sprintf("\t\t\"%s\": \"corkscrew-%s\",\n", service.Name, service.Name))
	}

	code := fmt.Sprintf(`package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/hashicorp/go-plugin"
	"github.com/jlgore/corkscrew/internal/client"
	"github.com/jlgore/corkscrew/internal/shared"
	pb "github.com/jlgore/corkscrew/internal/proto"
	"google.golang.org/protobuf/types/known/timestamppb"
)

const (
	ProviderName = "aws"
	Version      = "2.0.0"
)

// AWSProvider coordinates sophisticated scanner plugins
type AWSProvider struct {
	pluginManager *client.PluginManager
	initialized   bool
	region        string
	cacheDir      string
}

func NewAWSProvider() *AWSProvider {
	return &AWSProvider{}
}

func (p *AWSProvider) Initialize(ctx context.Context, req *pb.InitializeRequest) (*pb.InitializeResponse, error) {
	log.Printf("Initializing sophisticated AWS provider with region: %%s", req.Config["region"])

	// Initialize plugin manager
	pluginDir := "./build/plugins"
	if req.CacheDir != "" {
		pluginDir = req.CacheDir + "/plugins"
	}

	p.pluginManager = client.NewPluginManager(pluginDir)
	p.pluginManager.SetDebug(true)
	p.region = req.Config["region"]
	p.cacheDir = req.CacheDir
	p.initialized = true

	log.Printf("Sophisticated AWS provider initialized successfully")

	return &pb.InitializeResponse{
		Success: true,
		Version: Version,
	}, nil
}

func (p *AWSProvider) GetProviderInfo(ctx context.Context, req *pb.Empty) (*pb.ProviderInfoResponse, error) {
	return &pb.ProviderInfoResponse{
		Name:    ProviderName,
		Version: Version,
		SupportedServices: []string{
%s		},
		Capabilities: map[string]string{
			"streaming":              "true",
			"pagination":             "true",
			"parallelism":            "10",
			"relationships":          "true",
			"two_phase_scan":         "true",
			"hierarchical_discovery": "true",
			"sophisticated_plugins":  "true",
			"plugin_coordination":    "true",
		},
		Description: "Sophisticated AWS Cloud Provider with Plugin Architecture for Corkscrew",
	}, nil
}

func (p *AWSProvider) DiscoverServices(ctx context.Context, req *pb.DiscoverServicesRequest) (*pb.DiscoverServicesResponse, error) {
	if !p.initialized {
		return &pb.DiscoverServicesResponse{Services: []*pb.ServiceInfo{}}, fmt.Errorf("provider not initialized")
	}

	// Get available plugin mappings
	pluginMappings := map[string]string{
%s	}

	var services []*pb.ServiceInfo
	for serviceName, pluginName := range pluginMappings {
		services = append(services, &pb.ServiceInfo{
			Name:        serviceName,
			DisplayName: fmt.Sprintf("AWS %%s (Sophisticated Plugin)", serviceName),
			PackageName: pluginName,
		})
	}

	return &pb.DiscoverServicesResponse{
		Services:     services,
		DiscoveredAt: timestamppb.Now(),
		SdkVersion:   "2.0.0",
	}, nil
}

func (p *AWSProvider) GenerateServiceScanners(ctx context.Context, req *pb.GenerateScannersRequest) (*pb.GenerateScannersResponse, error) {
	// This provider coordinates existing sophisticated plugins rather than generating new ones
	var scanners []*pb.GeneratedScanner

	pluginMappings := map[string]string{
%s	}

	for _, serviceName := range req.Services {
		if pluginName, exists := pluginMappings[serviceName]; exists {
			scanners = append(scanners, &pb.GeneratedScanner{
				Service:     serviceName,
				FilePath:    fmt.Sprintf("./build/plugins/%%s", pluginName),
				GeneratedAt: timestamppb.Now(),
			})
		}
	}

	return &pb.GenerateScannersResponse{
		Scanners:       scanners,
		GeneratedCount: int32(len(scanners)),
	}, nil
}

func (p *AWSProvider) ListResources(ctx context.Context, req *pb.ListResourcesRequest) (*pb.ListResourcesResponse, error) {
	if !p.initialized {
		return &pb.ListResourcesResponse{Resources: []*pb.ResourceRef{}}, fmt.Errorf("provider not initialized")
	}

	// Use sophisticated scanner plugin for this service
	scanReq := &pb.ScanRequest{
		Region:        req.Region,
		ResourceTypes: []string{req.ResourceType},
		Options:       req.Filters,
	}

	resp, err := p.pluginManager.ScanServiceWithPlugin(ctx, req.Service, req.Region, scanReq)
	if err != nil {
		return &pb.ListResourcesResponse{Resources: []*pb.ResourceRef{}}, err
	}

	// Convert resources to resource refs
	var refs []*pb.ResourceRef
	for _, resource := range resp.Resources {
		refs = append(refs, &pb.ResourceRef{
			Id:     resource.Id,
			Name:   resource.Name,
			Type:   resource.Type,
			Service: resource.Service,
			Region: resource.Region,
		})
	}

	return &pb.ListResourcesResponse{
		Resources:  refs,
		TotalCount: int32(len(refs)),
	}, nil
}

func (p *AWSProvider) DescribeResource(ctx context.Context, req *pb.DescribeResourceRequest) (*pb.DescribeResourceResponse, error) {
	if !p.initialized {
		return &pb.DescribeResourceResponse{}, fmt.Errorf("provider not initialized")
	}

	// Use sophisticated scanner plugin to get detailed resource information
	scanReq := &pb.ScanRequest{
		Region:  req.ResourceRef.Region,
		Options: map[string]string{"resource_id": req.ResourceRef.Id},
	}

	resp, err := p.pluginManager.ScanServiceWithPlugin(ctx, req.ResourceRef.Service, req.ResourceRef.Region, scanReq)
	if err != nil {
		return &pb.DescribeResourceResponse{}, err
	}

	// Find the specific resource
	for _, resource := range resp.Resources {
		if resource.Id == req.ResourceRef.Id {
			return &pb.DescribeResourceResponse{Resource: resource}, nil
		}
	}

	return &pb.DescribeResourceResponse{}, fmt.Errorf("resource not found")
}

func (p *AWSProvider) BatchScan(ctx context.Context, req *pb.BatchScanRequest) (*pb.BatchScanResponse, error) {
	if !p.initialized {
		return &pb.BatchScanResponse{Resources: []*pb.Resource{}}, fmt.Errorf("provider not initialized")
	}

	log.Printf("Starting sophisticated batch scan for %%d services", len(req.Services))

	// Use sophisticated plugin manager for batch scanning
	return p.pluginManager.BatchScanWithPlugins(ctx, req.Services, req.Region, req.Filters)
}

func (p *AWSProvider) GetSchemas(ctx context.Context, req *pb.GetSchemasRequest) (*pb.SchemaResponse, error) {
	if !p.initialized {
		return &pb.SchemaResponse{Schemas: []*pb.Schema{}}, fmt.Errorf("provider not initialized")
	}

	// Get schemas from sophisticated scanner plugins
	return p.pluginManager.GetSchemasFromPlugins(ctx, req.Services)
}

func (p *AWSProvider) StreamScan(req *pb.StreamScanRequest, stream pb.CloudProvider_StreamScanServer) error {
	if !p.initialized {
		return fmt.Errorf("provider not initialized")
	}

	ctx := stream.Context()

	// Stream from sophisticated scanner plugins
	for _, serviceName := range req.Services {
		scanReq := &pb.ScanRequest{
			Region:        req.Region,
			ResourceTypes: req.ResourceTypes,
			Options:       req.Filters,
		}

		// Create a streaming adapter
		streamAdapter := &streamAdapter{stream: stream}
		
		err := p.pluginManager.StreamScanServiceWithPlugin(ctx, serviceName, req.Region, scanReq, streamAdapter)
		if err != nil {
			log.Printf("Failed to stream from %%s plugin: %%v", serviceName, err)
			continue
		}
	}

	return nil
}

// streamAdapter adapts CloudProvider stream to Scanner stream
type streamAdapter struct {
	stream pb.CloudProvider_StreamScanServer
}

func (sa *streamAdapter) Send(resource *pb.Resource) error {
	return sa.stream.Send(resource)
}

func (sa *streamAdapter) Context() context.Context {
	return sa.stream.Context()
}

func main() {
	provider := NewAWSProvider()
	
	plugin.Serve(&plugin.ServeConfig{
		HandshakeConfig: shared.HandshakeConfig,
		Plugins: map[string]plugin.Plugin{
			"provider": &shared.CloudProviderGRPCPlugin{
				Impl: provider,
			},
		},
		GRPCServer: plugin.DefaultGRPCServer,
	})
}
`, serviceNames.String(), pluginLoaders.String(), pluginLoaders.String())

	return code, nil
}

// Helper types and functions

type GenerationResult struct {
	GeneratedPlugins   map[string]*GeneratedPlugin
	Errors             []string
	TotalServices      int
	SuccessfulServices int
	BuildScriptPath    string
	ConfigPath         string
}

type GeneratedPlugin struct {
	ServiceName   string
	FilePath      string
	BinaryName    string
	ResourceTypes []string
	Operations    []string
	Capabilities  []string
	RequiredPerms []string
	GeneratedAt   string
}

func extractResourceTypes(service *AWSServiceInfo) []string {
	var types []string
	for _, rt := range service.ResourceTypes {
		if len(rt.Operations) > 0 {
			types = append(types, rt.Name)
		}
	}
	return types
}

func extractOperations(service *AWSServiceInfo) []string {
	var ops []string
	for _, op := range service.Operations {
		if op.IsList || op.IsDescribe || op.IsGet {
			ops = append(ops, op.Name)
		}
	}
	return ops
}

func extractRequiredPermissions(service *AWSServiceInfo) []string {
	var perms []string
	for _, op := range service.Operations {
		if op.IsList || op.IsDescribe || op.IsGet {
			perms = append(perms, fmt.Sprintf("%s:%s", strings.ToLower(service.Name), op.Name))
		}
	}
	return perms
}

func formatResourceTypes(service *AWSServiceInfo) string {
	types := extractResourceTypes(service)
	if len(types) == 0 {
		return "[]"
	}
	return fmt.Sprintf("[\"%s\"]", strings.Join(types, "\", \""))
}

func formatRequiredPermissions(service *AWSServiceInfo) string {
	perms := extractRequiredPermissions(service)
	if len(perms) == 0 {
		return "[]"
	}
	return fmt.Sprintf("[\"%s\"]", strings.Join(perms, "\", \""))
}
