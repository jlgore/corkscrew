package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/jlgore/corkscrew/plugins/aws-provider/registry"
)

// ClientFactoryGenerator generates dynamic client factory code
type ClientFactoryGenerator struct {
	registry       registry.DynamicServiceRegistry
	outputPath     string
	packageName    string
	buildTag       string
	enableFallback bool
}

// NewClientFactoryGenerator creates a new client factory generator
func NewClientFactoryGenerator(reg registry.DynamicServiceRegistry, outputPath string) *ClientFactoryGenerator {
	return &ClientFactoryGenerator{
		registry:       reg,
		outputPath:     outputPath,
		packageName:    "main",
		buildTag:       "aws_services",
		enableFallback: true,
	}
}

// GenerateClientFactory generates the client factory code
func (g *ClientFactoryGenerator) GenerateClientFactory() error {
	// Get all services from registry
	services := g.registry.ListServiceDefinitions()
	if len(services) == 0 {
		return fmt.Errorf("no services found in registry")
	}

	// Sort services for consistent output
	sort.Slice(services, func(i, j int) bool {
		return services[i].Name < services[j].Name
	})

	// Generate the code
	code, err := g.generateCode(services)
	if err != nil {
		return fmt.Errorf("failed to generate code: %w", err)
	}

	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		return fmt.Errorf("failed to format code: %w", err)
	}

	// Ensure output directory exists
	dir := filepath.Dir(g.outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Write to file
	if err := os.WriteFile(g.outputPath, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// generateCode generates the client factory code from template
func (g *ClientFactoryGenerator) generateCode(services []registry.ServiceDefinition) (string, error) {
	tmpl := template.Must(template.New("clientFactory").Funcs(template.FuncMap{
		"extractPackageName": extractPackageName,
		"formatComment":      formatComment,
		"needsRegion":        needsRegion,
	}).Parse(clientFactoryTemplate))

	data := struct {
		BuildTag       string
		PackageName    string
		GeneratedAt    string
		Services       []registry.ServiceDefinition
		EnableFallback bool
	}{
		BuildTag:       g.buildTag,
		PackageName:    g.packageName,
		GeneratedAt:    time.Now().Format(time.RFC3339),
		Services:       services,
		EnableFallback: g.enableFallback,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// GenerateDynamicWrapper generates a wrapper that uses the registry at runtime
func (g *ClientFactoryGenerator) GenerateDynamicWrapper() error {
	code := dynamicWrapperTemplate
	
	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		return fmt.Errorf("failed to format wrapper code: %w", err)
	}

	// Write wrapper file
	wrapperPath := strings.Replace(g.outputPath, ".go", "_dynamic.go", 1)
	if err := os.WriteFile(wrapperPath, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write wrapper file: %w", err)
	}

	return nil
}

// GenerateReflectionFallback generates the reflection-based fallback
func (g *ClientFactoryGenerator) GenerateReflectionFallback() error {
	code := reflectionFallbackTemplate

	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		return fmt.Errorf("failed to format fallback code: %w", err)
	}

	// Write fallback file
	fallbackPath := strings.Replace(g.outputPath, ".go", "_reflection.go", 1)
	if err := os.WriteFile(fallbackPath, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write fallback file: %w", err)
	}

	return nil
}

// Helper functions
func extractPackageName(packagePath string) string {
	parts := strings.Split(packagePath, "/")
	return parts[len(parts)-1]
}

func formatComment(s string) string {
	if s == "" {
		return ""
	}
	return "// " + s
}

func needsRegion(service registry.ServiceDefinition) bool {
	return service.RequiresRegion && !service.GlobalService
}

// Template for generated client factory
const clientFactoryTemplate = `// Code generated by client_factory_generator.go at {{ .GeneratedAt }}. DO NOT EDIT.
// +build {{ .BuildTag }}

package {{ .PackageName }}

import (
	"context"
	"fmt"
	"sync"
	
	"github.com/aws/aws-sdk-go-v2/aws"
	{{ range .Services }}
	{{ if .PackagePath }}{{ extractPackageName .PackagePath }} "{{ .PackagePath }}"{{ end }}
	{{ end }}
)

// DynamicClientFactory creates AWS service clients dynamically
type DynamicClientFactory struct {
	config   aws.Config
	clients  sync.Map // Cache created clients
	registry ServiceRegistry
}

// NewDynamicClientFactory creates a new dynamic client factory
func NewDynamicClientFactory(cfg aws.Config, registry ServiceRegistry) *DynamicClientFactory {
	return &DynamicClientFactory{
		config:   cfg,
		registry: registry,
	}
}

// CreateClient creates a client for the specified service
func (f *DynamicClientFactory) CreateClient(ctx context.Context, serviceName string) (interface{}, error) {
	// Check cache first
	if client, ok := f.clients.Load(serviceName); ok {
		return client, nil
	}

	// Get service definition from registry
	service, exists := f.registry.GetService(serviceName)
	if !exists {
		{{ if .EnableFallback }}
		return f.createClientViaReflection(ctx, serviceName)
		{{ else }}
		return nil, fmt.Errorf("unknown service: %s", serviceName)
		{{ end }}
	}

	// Create client based on service name
	var client interface{}
	var err error

	switch serviceName {
	{{ range .Services }}
	case "{{ .Name }}":
		{{ if .PackagePath }}
		{{ if needsRegion . }}
		// Service requires region configuration
		if f.config.Region == "" {
			return nil, fmt.Errorf("service %s requires region to be set", serviceName)
		}
		{{ end }}
		client = {{ extractPackageName .PackagePath }}.NewFromConfig(f.config)
		{{ else }}
		// Service package not available, use reflection
		client, err = f.createClientViaReflection(ctx, "{{ .Name }}")
		{{ end }}
	{{ end }}
	default:
		{{ if .EnableFallback }}
		client, err = f.createClientViaReflection(ctx, serviceName)
		{{ else }}
		return nil, fmt.Errorf("unsupported service: %s", serviceName)
		{{ end }}
	}

	if err != nil {
		return nil, fmt.Errorf("failed to create client for %s: %w", serviceName, err)
	}

	// Cache the client
	f.clients.Store(serviceName, client)
	return client, nil
}

// GetClient retrieves an existing client or creates a new one
func (f *DynamicClientFactory) GetClient(ctx context.Context, serviceName string) (interface{}, error) {
	return f.CreateClient(ctx, serviceName)
}

// ListAvailableServices returns all services that can be instantiated
func (f *DynamicClientFactory) ListAvailableServices() []string {
	return f.registry.ListServices()
}

// GetServiceInfo returns information about a service
func (f *DynamicClientFactory) GetServiceInfo(serviceName string) (*ServiceInfo, error) {
	service, exists := f.registry.GetService(serviceName)
	if !exists {
		return nil, fmt.Errorf("service not found: %s", serviceName)
	}

	return &ServiceInfo{
		Name:        service.Name,
		DisplayName: service.DisplayName,
		Description: service.Description,
		RateLimit:   service.RateLimit,
		BurstLimit:  service.BurstLimit,
		IsGlobal:    service.GlobalService,
		RequiresRegion: service.RequiresRegion,
	}, nil
}

// ClearCache clears the client cache
func (f *DynamicClientFactory) ClearCache() {
	f.clients = sync.Map{}
}

// ServiceInfo provides basic service information
type ServiceInfo struct {
	Name           string
	DisplayName    string
	Description    string
	RateLimit      float64
	BurstLimit     int
	IsGlobal       bool
	RequiresRegion bool
}

// ServiceRegistry interface for accessing service definitions
type ServiceRegistry interface {
	GetService(name string) (*ServiceDefinition, bool)
	ListServices() []string
}

{{ if .EnableFallback }}
// createClientViaReflection is defined in client_factory_reflection.go
func (f *DynamicClientFactory) createClientViaReflection(ctx context.Context, serviceName string) (interface{}, error) {
	return createClientUsingReflection(serviceName, f.config, f.registry)
}
{{ end }}
`

// Template for dynamic wrapper that uses registry at runtime
const dynamicWrapperTemplate = `// Code generated by client_factory_generator.go. DO NOT EDIT.

package main

import (
	"context"
	"fmt"
	"reflect"
	"strings"
	"sync"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/jlgore/corkscrew/plugins/aws-provider/registry"
	"golang.org/x/time/rate"
)

// RuntimeClientFactory creates clients using registry at runtime
type RuntimeClientFactory struct {
	config      aws.Config
	registry    registry.DynamicServiceRegistry
	clientCache sync.Map
	limiter     sync.Map // Per-service rate limiters
}

// NewRuntimeClientFactory creates a new runtime client factory
func NewRuntimeClientFactory(cfg aws.Config, reg registry.DynamicServiceRegistry) *RuntimeClientFactory {
	return &RuntimeClientFactory{
		config:   cfg,
		registry: reg,
	}
}

// CreateClient creates a client dynamically at runtime
func (f *RuntimeClientFactory) CreateClient(ctx context.Context, serviceName string) (interface{}, error) {
	// Normalize service name
	serviceName = strings.ToLower(serviceName)

	// Check cache
	if cached, ok := f.clientCache.Load(serviceName); ok {
		return cached, nil
	}

	// Get service definition
	service, exists := f.registry.GetService(serviceName)
	if !exists {
		return nil, fmt.Errorf("service %s not registered", serviceName)
	}

	// Check region requirement
	if service.RequiresRegion && !service.GlobalService && f.config.Region == "" {
		return nil, fmt.Errorf("service %s requires region configuration", serviceName)
	}

	// Create client using reflection
	client, err := f.createClientReflectively(service)
	if err != nil {
		return nil, fmt.Errorf("failed to create %s client: %w", serviceName, err)
	}

	// Cache the client
	f.clientCache.Store(serviceName, client)

	// Create rate limiter for service
	limiter := rate.NewLimiter(service.RateLimit, service.BurstLimit)
	f.limiter.Store(serviceName, limiter)

	return client, nil
}

// GetRateLimiter returns the rate limiter for a service
func (f *RuntimeClientFactory) GetRateLimiter(serviceName string) *rate.Limiter {
	if limiter, ok := f.limiter.Load(serviceName); ok {
		return limiter.(*rate.Limiter)
	}

	// Get service to create limiter
	service, exists := f.registry.GetService(serviceName)
	if !exists {
		// Return default limiter
		return rate.NewLimiter(10, 20)
	}

	limiter := rate.NewLimiter(service.RateLimit, service.BurstLimit)
	f.limiter.Store(serviceName, limiter)
	return limiter
}

// createClientReflectively creates a client using reflection
func (f *RuntimeClientFactory) createClientReflectively(service *registry.ServiceDefinition) (interface{}, error) {
	// This will be implemented by the reflection module
	// For now, return error
	return nil, fmt.Errorf("reflection-based client creation not yet implemented for %s", service.Name)
}

// GetAvailableServices returns all registered services
func (f *RuntimeClientFactory) GetAvailableServices() []string {
	return f.registry.ListServices()
}

// GetServiceMetadata returns detailed service information
func (f *RuntimeClientFactory) GetServiceMetadata(serviceName string) (*ServiceMetadata, error) {
	service, exists := f.registry.GetService(serviceName)
	if !exists {
		return nil, fmt.Errorf("service not found: %s", serviceName)
	}

	return &ServiceMetadata{
		Name:                    service.Name,
		DisplayName:             service.DisplayName,
		Description:             service.Description,
		PackagePath:             service.PackagePath,
		ClientType:              service.ClientType,
		ResourceTypes:           len(service.ResourceTypes),
		Operations:              len(service.Operations),
		RateLimit:               float64(service.RateLimit),
		BurstLimit:              service.BurstLimit,
		RequiresRegion:          service.RequiresRegion,
		GlobalService:           service.GlobalService,
		SupportsPagination:      service.SupportsPagination,
		SupportsResourceExplorer: service.SupportsResourceExplorer,
	}, nil
}

// ServiceMetadata contains runtime service information
type ServiceMetadata struct {
	Name                    string
	DisplayName             string
	Description             string
	PackagePath             string
	ClientType              string
	ResourceTypes           int
	Operations              int
	RateLimit               float64
	BurstLimit              int
	RequiresRegion          bool
	GlobalService           bool
	SupportsPagination      bool
	SupportsResourceExplorer bool
}

// InvalidateCache removes a service client from cache
func (f *RuntimeClientFactory) InvalidateCache(serviceName string) {
	f.clientCache.Delete(serviceName)
	f.limiter.Delete(serviceName)
}

// ClearAllCaches clears all cached clients and limiters
func (f *RuntimeClientFactory) ClearAllCaches() {
	f.clientCache = sync.Map{}
	f.limiter = sync.Map{}
}

// UpdateRegistry updates the underlying service registry
func (f *RuntimeClientFactory) UpdateRegistry(reg registry.DynamicServiceRegistry) {
	f.registry = reg
	f.ClearAllCaches() // Clear caches when registry changes
}
`

// Template for reflection-based fallback
const reflectionFallbackTemplate = `// Code generated by client_factory_generator.go. DO NOT EDIT.

package main

import (
	"fmt"
	"plugin"
	"reflect"
	"strings"

	"github.com/aws/aws-sdk-go-v2/aws"
)

// ReflectionClientCreator handles reflection-based client creation
type ReflectionClientCreator struct {
	loadedPlugins map[string]*plugin.Plugin
	clientTypes   map[string]reflect.Type
}

// NewReflectionClientCreator creates a new reflection-based client creator
func NewReflectionClientCreator() *ReflectionClientCreator {
	return &ReflectionClientCreator{
		loadedPlugins: make(map[string]*plugin.Plugin),
		clientTypes:   make(map[string]reflect.Type),
	}
}

// createClientUsingReflection creates a client using reflection
func createClientUsingReflection(serviceName string, config aws.Config, registry ServiceRegistry) (interface{}, error) {
	service, exists := registry.GetService(serviceName)
	if !exists {
		return nil, fmt.Errorf("service %s not found in registry", serviceName)
	}

	// Try to load the service package dynamically
	// This is a simplified version - real implementation would need more sophistication
	
	// Method 1: Use pre-registered types (requires registration at compile time)
	creator := getGlobalCreator()
	if clientType, ok := creator.clientTypes[serviceName]; ok {
		return createFromType(clientType, config)
	}

	// Method 2: Try to load from plugin (requires services as plugins)
	if service.PackagePath != "" {
		client, err := creator.loadFromPlugin(serviceName, service.PackagePath, config)
		if err == nil {
			return client, nil
		}
	}

	// Method 3: Use generic interface (requires services to implement common interface)
	return createGenericClient(serviceName, config)
}

// Global creator instance
var globalCreator = NewReflectionClientCreator()

func getGlobalCreator() *ReflectionClientCreator {
	return globalCreator
}

// RegisterClientType registers a client type for reflection-based creation
func RegisterClientType(serviceName string, clientType reflect.Type) {
	globalCreator.clientTypes[strings.ToLower(serviceName)] = clientType
}

// createFromType creates a client from a registered type
func createFromType(clientType reflect.Type, config aws.Config) (interface{}, error) {
	// Look for NewFromConfig method
	method, ok := clientType.MethodByName("NewFromConfig")
	if !ok {
		return nil, fmt.Errorf("type %s does not have NewFromConfig method", clientType.Name())
	}

	// Call the method
	configValue := reflect.ValueOf(config)
	results := method.Func.Call([]reflect.Value{configValue})
	
	if len(results) == 0 {
		return nil, fmt.Errorf("NewFromConfig returned no results")
	}

	return results[0].Interface(), nil
}

// loadFromPlugin attempts to load a service client from a plugin
func (r *ReflectionClientCreator) loadFromPlugin(serviceName, packagePath string, config aws.Config) (interface{}, error) {
	// Check if plugin already loaded
	if p, ok := r.loadedPlugins[serviceName]; ok {
		return createClientFromPlugin(p, config)
	}

	// Try to load plugin (this would need actual plugin files)
	pluginPath := fmt.Sprintf("/usr/lib/corkscrew/plugins/aws-%s.so", serviceName)
	p, err := plugin.Open(pluginPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load plugin for %s: %w", serviceName, err)
	}

	r.loadedPlugins[serviceName] = p
	return createClientFromPlugin(p, config)
}

// createClientFromPlugin creates a client from a loaded plugin
func createClientFromPlugin(p *plugin.Plugin, config aws.Config) (interface{}, error) {
	// Look for NewClient symbol
	symbol, err := p.Lookup("NewClient")
	if err != nil {
		return nil, fmt.Errorf("plugin missing NewClient function: %w", err)
	}

	// Try to call it as a function
	newClientFunc, ok := symbol.(func(aws.Config) interface{})
	if !ok {
		return nil, fmt.Errorf("NewClient has unexpected signature")
	}

	return newClientFunc(config), nil
}

// createGenericClient creates a generic client implementation
func createGenericClient(serviceName string, config aws.Config) (interface{}, error) {
	// This would return a generic client that uses the AWS SDK's low-level API
	// For now, return an error
	return nil, fmt.Errorf("generic client creation not implemented for %s", serviceName)
}

// DynamicServiceClient provides a generic interface for AWS service clients
type DynamicServiceClient struct {
	ServiceName string
	Config      aws.Config
	Endpoint    string
}

// NewDynamicServiceClient creates a new dynamic service client
func NewDynamicServiceClient(serviceName string, config aws.Config) *DynamicServiceClient {
	return &DynamicServiceClient{
		ServiceName: serviceName,
		Config:      config,
	}
}

// Invoke invokes an operation on the service
func (c *DynamicServiceClient) Invoke(operation string, input interface{}) (interface{}, error) {
	// This would use the low-level AWS SDK API to invoke operations
	// For now, return an error
	return nil, fmt.Errorf("dynamic invocation not implemented")
}
`